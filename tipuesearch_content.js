var tipuesearch = {"pages":[{"title":"About me","text":"Hello, this is 单金哲(Jinzhe Shan). You can find me at LinkedIn . You can alse feel free to email me at any time.","tags":"pages","url":"/about","loc":"/about"},{"title":"剑指offer|解题代码-2-Tree","text":"目录： [TOC] Tree 004-重建二叉树 √ 2019-3-6 13:09 --- 2019-3-6 13:24 题目描述：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 分析： 1. 前序遍历的第一个元素为树的根节点 root， 后面n个左子树元素，m个右子树元素 2. 中序遍历中 root结点的左边元素为所有左子树元素共n个， 右边元素为所有右子树元素共m个 思路：递归方法 1. 前序遍历第一个元素为 root 2. 中序遍历找到root的index， [:index]为左子树的中序遍历， [index+1:]为右子树中序遍历 3. 前序遍历中 [1:index+1]为左子树的前序遍历，[index+1:]为右子树的前序遍历 4. 递归 传入左子树和右子树的前序/中序遍历 5. 递归终止条件： 前序/中序遍历为空 return None 解题代码：（java） /** * Definition for binary tree * public class TreeNode { * int val ; * TreeNode left ; * TreeNode right ; * TreeNode ( int x ) { val = x ; } * } */ import java.util.Arrays ; public class Solution { public TreeNode reConstructBinaryTree ( int [] pre , int [] in ) { if ( pre . length == 0 || in . length == 0 ) return null ; TreeNode root = new TreeNode ( pre [ 0 ]); int index = 0 ; for ( int i = 0 ; i < in . length ; i ++ ){ if ( pre [ 0 ] == in [ i ]){ index = i ; break ; } } int [] leftPre = Arrays . copyOfRange ( pre , 1 , index + 1 ); int [] leftIn = Arrays . copyOfRange ( in , 0 , index ); int [] rightPre = Arrays . copyOfRange ( pre , index + 1 , pre . length ); int [] rightIn = Arrays . copyOfRange ( in , index + 1 , in . length ); root . left = reConstructBinaryTree ( leftPre , leftIn ); root . right = reConstructBinaryTree ( rightPre , rightIn ); return root ; } } 解题代码：（Python） # -*- coding:utf-8 -*- # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution : # 返回构造的TreeNode根节点 def reConstructBinaryTree ( self , pre , tin ): if not pre or not tin : return None root = TreeNode ( pre [ 0 ]) index = tin . index ( pre [ 0 ]) root . left = self . reConstructBinaryTree ( pre [ 1 : index + 1 ], tin [: index ]) root . right = self . reConstructBinaryTree ( pre [ index + 1 :], tin [ index + 1 :]) return root 017-树的子结构 √ 题目描述 : 输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） 思路： 遍历树A，找到值与树B root值相同的结点 执行判断函数，检查左右孩子结点是否相同 解题代码：（Java） /** public class TreeNode { int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) { this.val = val; } } */ public class Solution { public boolean HasSubtree ( TreeNode root1 , TreeNode root2 ) { boolean result = false ; if ( root1 != null && root2 != null ){ if ( root1 . val == root2 . val ) result = isTree1HasTree2 ( root1 , root2 ); if ( result != true ) result = HasSubtree ( root1 . left , root2 ); if ( result != true ) result = HasSubtree ( root1 . right , root2 ); } return result ; } public boolean isTree1HasTree2 ( TreeNode root1 , TreeNode root2 ){ if ( root2 == null ) return true ; if ( root1 == null ) return false ; if ( root1 . val != root2 . val ) return false ; return isTree1HasTree2 ( root1 . left , root2 . left ) && isTree1HasTree2 ( root1 . right , root2 . right ); } } 018-二叉树的镜像 √ 题目描述 : 操作给定的二叉树，将其变换为源二叉树的镜像。 思路： 递归遍历二叉树，交换每一个节点的左右孩子 解题代码：（Java） public class Solution { public void Mirror ( TreeNode root ) { if ( root != null ){ // swap left and right child TreeNode temNode = root . left ; root . left = root . right ; root . right = temNode ; if ( root . left != null ) Mirror ( root . left ); if ( root . right != null ) Mirror ( root . right ); } } } 022-从上往下打印二叉树 （二叉树按层遍历）√ 题目描述 : 从上往下打印出二叉树的每个节点，同层节点从左至右打印。 思路： 1. Queue 将 root,root.left,root.right 依次加入Queue 补充知识： Java 集合 - LinkedList vs Queue 1. import java.util.LinkedList; 2. LinkedList queue = new LinkedList (); 3. queue.isEmpty(); // 判断是否为空 3. queue.offer();//将节点入队 （Push） 4. queue.poll();//队头元素出队并返回 (Pop) 解题代码：（Java） import java.util.ArrayList ; import java.util.LinkedList ; import java.util.Queue ; /** public class TreeNode { int val = 0 ; TreeNode left = null ; TreeNode right = null ; public TreeNode ( int val ) { this . val = val ; } } */ public class Solution { public ArrayList < Integer > PrintFromTopToBottom ( TreeNode root ) { ArrayList < Integer > resList = new ArrayList < Integer > (); Queue < TreeNode > queue = new LinkedList < TreeNode > (); // debug ： new LinkedList < TreeNode > () <> 后的括号 () 漏了！注意细节。 if ( root == null ) return resList ; TreeNode curNode = null ; queue . offer ( root ); while ( ! queue . isEmpty ()){ curNode = queue . poll (); if ( curNode . left != null ){ queue . offer ( curNode . left ); } if ( curNode . right != null ){ queue . offer ( curNode . right ); } resList . add ( curNode . val ); } return resList ; } } 023-二叉搜索树的后序遍历序列 √ 题目描述 : 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。 补充知识 1 ： 二叉搜索树(Binary Search Tree) or 排序二叉树（Sorted Binary Tree） 1. 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值； 2. 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值； 3. 任意节点的左、右子树也分别为二叉查找树； 4. 没有键值相等的节点。 补充知识 2 ： 树的前中后序遍历，前中后是指根节点root被打印的顺序，后序意味着打印顺序为 左右根 例如： [5，7，6] 可以是 BST 5-6-7 的后序遍历，故返回Ture，然而并没有一棵BST的后序遍历能够为 [7,4,6,5] 分析后可以得知，BST 后序遍历的序列有如下特征： 1. 最后一个节点为 root 2. [0] - [len-2] 被分成两段，前一段为root的左孩子节点，值都小于root.val， 后一段为root 的右孩子节点，值都大于root.val 3. 根据 BST 的特性，对左右孩子进行递归调用继续判断 解题代码：（Java） // 问题主要在于：一直在 copy 数组，效率较低 import java.util.Arrays ; public class Solution { public boolean VerifySquenceOfBST ( int [] sequence ) { int len = sequence . length ; if ( len <= 0 || sequence == null ) return false ; int rootVal = sequence [ len - 1 ]; int i = 0 ; for (; i < len - 1 ; i ++ ){ if ( sequence [ i ] > rootVal ){ break ; } } int index = i ; for ( int j = i ; j < len - 1 ; j ++ ){ if ( sequence [ j ] < rootVal ) return false ; } boolean left = true ; boolean right = true ; if ( index > 0 ){ int [] leftNodes = Arrays . copyOfRange ( sequence , 0 , index ); left = VerifySquenceOfBST ( leftNodes ); } if ( index < len - 1 ){ int [] rightNodes = Arrays . copyOfRange ( sequence , index , len - 1 ); right = VerifySquenceOfBST ( rightNodes ); } return ( left && right ); } } 024-二叉树中和为某一值的路径 √ 20190924 总结： 这题前前后后刷了差不多2个小时 题目描述 : 输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前) 思路： 1. 每次都从根节点出发，需要一个栈结构记录路径 path，方便回溯，一个 int currentVal 记录当前路径节点值之和 2. 当 currentVal == targetVal 且 currentNode 是叶子节点时，输出路径path （逆序） 3. 当有孩子节点时递归调用 FindPath方法 4. 注意： 如果当前节点为叶子节点但 currentVal ！= targetVal 则需要把 currentVal - currentNode.val 且 从路径中删除当前节点，然后返回父节点 import java.util.ArrayList ; import java.util.Stack ; /** public class TreeNode { int val = 0 ; TreeNode left = null ; TreeNode right = null ; public TreeNode ( int val ) { this . val = val ; } } */ public class Solution { static ArrayList < ArrayList < Integer >> res = new ArrayList <> (); public ArrayList < ArrayList < Integer >> FindPath ( TreeNode root , int target ) { if ( root == null ) return null ; Stack < Integer > path = new Stack (); int currentVal = 0 ; FindPath ( root , target , path , currentVal ); System . out . println ( res ); return res ; } public void FindPath ( TreeNode root , int target , Stack < Integer > path , int currentVal ){ path . push ( root . val ); currentVal += root . val ; boolean isLeaf = ( root . left == null && root . right == null ); if ( currentVal == target && isLeaf ){ ArrayList < Integer > oneRes = new ArrayList <> (); while ( ! path . isEmpty ()){ oneRes . add ( 0 , path . pop ()); } res . add ( oneRes ); } // if no new path 2 , leftNodes will influence rightNodes Stack < Integer > path2 = new Stack (); path2 . addAll ( path ); if ( root . left != null ) FindPath ( root . left , target , path , currentVal ); if ( root . right != null ) FindPath ( root . right , target , path2 , currentVal ); // if can not find the path , delete the current node from the path and add if ( ! path . isEmpty ()) path . pop (); currentVal -= root . val ; } } 解题代码2（Java） public class Solution { public ArrayList < ArrayList < Integer >> FindPath ( TreeNode root , int target ) { ArrayList < ArrayList < Integer >> paths = new ArrayList < ArrayList < Integer >> () ; if ( root == null ) return paths ; find ( paths , new ArrayList < Integer > () , root , target ) ; return paths ; } public void find ( ArrayList < ArrayList < Integer >> paths , ArrayList < Integer > path , TreeNode root , int target ) { path . add ( root . val ) ; if ( root . left == null && root . right == null ) { if ( target == root . val ) { paths . add ( path ) ; } return ; } ArrayList < Integer > path2 = new ArrayList <> () ; path2 . addAll ( path ) ; if ( root . left != null ) find ( paths , path , root . left , target - root . val ) ; if ( root . right != null ) find ( paths , path2 , root . right , target - root . val ) ; } } 026-二叉搜索树与双向链表 √ 题目描述 : 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 思路： 1. 记录链表末尾节点 tail 2. 中序遍历，连接 tail 和 pRoot 3. 建议画图理解 else 内的3行连接代码 解题代码：（Java） /** public class TreeNode { int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) { this.val = val; } } */ public class Solution { TreeNode root = null ; // real root as return value TreeNode tail = null ; // the last node of LinkedList public TreeNode Convert ( TreeNode pRootOfTree ) { if ( pRootOfTree == null ) return null ; if ( pRootOfTree . left != null ) Convert ( pRootOfTree . left ) ; if ( root == null ) { root = pRootOfTree ; tail = pRootOfTree ; } else { // Link tail . right = pRootOfTree ; pRootOfTree . left = tail ; tail = pRootOfTree ; } if ( pRootOfTree . right != null ) Convert ( pRootOfTree . right ) ; return root ; } } 038-二叉树的深度 √ 题目描述 : 输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 解题代码：（Java） public class Solution { public int TreeDepth ( TreeNode root ) { if ( root == null ) return 0 ; int left = TreeDepth ( root . left ) ; int right = TreeDepth ( root . right ) ; return Math . max ( left , right ) + 1 ; } } 039-平衡二叉树 √ 题目描述 : 输入一棵二叉树，判断该二叉树是否是平衡二叉树。 补充知识： 平衡二叉树 平衡二叉树是一棵 空树 或它的 左右两个子树的高度差的绝对值不超过1 ，并且左右两个子树都是一棵平衡二叉树 思路： 非常直白，只需要计算左右子树高度，并且判断高度差是否小于等于1 解题代码 1：（Java） public class Solution { public boolean IsBalanced_Solution ( TreeNode root ) { return getDepth ( root ) != - 1 ; } public int getDepth ( TreeNode root ) { if ( root == null ) return 0 ; int left = getDepth ( root . left ) ; if ( left == - 1 ) return - 1 ; int right = getDepth ( root . right ) ; if ( right == - 1 ) return - 1 ; return Math . abs ( left - right ) > 1 ? - 1 : Math . max ( left , right ) + 1 ; } } 解题代码 2： (java) import java.lang.Math ; public class Solution { public boolean IsBalanced_Solution ( TreeNode root ) { if ( root == null ) return true ; int left = getDepth ( root . left ); int right = getDepth ( root . right ); return Math . abs ( left - right ) <= 1 ; } public int getDepth ( TreeNode root ) { if ( root == null ) return 0 ; int left = getDepth ( root . left ); int right = getDepth ( root . right ); return Math . max ( left , right ) + 1 ; } } 057-二叉树的下一个结点 ** √ 题目描述 : 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 思路： 1. 有右孩子，则为右子树的最左节点 2. ==无右孩子，则找父节点，直到当前节点为其父节点的左孩子时，返回父节点== 解题代码：（Java） /* public class TreeLinkNode { int val; TreeLinkNode left = null; TreeLinkNode right = null; TreeLinkNode next = null; TreeLinkNode(int val) { this.val = val; } } */ public class Solution { public TreeLinkNode GetNext ( TreeLinkNode pNode ) { if ( pNode == null ) return pNode ; // 有右孩子，则为右子树的最左节点 if ( pNode . right != null ) return getLeftMost ( pNode . right ) ; // 无右孩子，则找父节点，直到当前节点为其父节点的左孩子时，返回父节点 else { TreeLinkNode parent = pNode . next ; while ( parent != null && parent . left != pNode ) { pNode = parent ; parent = pNode . next ; } return parent ; } } public TreeLinkNode getLeftMost ( TreeLinkNode node ) { if ( node == null ) return node ; while ( node . left != null ) { node = node . left ; } return node ; } } 058-对称的二叉树 √ 题目描述 : 请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。 思路： 判断左子树和右子树对称 解题代码：（Java） public class Solution { boolean isSymmetrical ( TreeNode pRoot ) { if ( pRoot == null ) return true ; return isSymmetrical ( pRoot . left , pRoot . right ); } boolean isSymmetrical ( TreeNode r1 , TreeNode r2 ){ if ( r1 == null && r2 == null ) return true ; if ( r1 != null && r2 != null ) return r1 . val == r2 . val && isSymmetrical ( r1 . left , r2 . right ) && isSymmetrical ( r1 . right , r2 . left ); return false ; } } 059-按之字形顺序打印二叉树 √ 思路： 1. 层序遍历的思想 （队列） 2. 左右打印顺序用一个boolean flag来控制 基于层序遍历按层输出的代码，加入reverse，并不需要两个stack 核心： 1. preLayerLastNode 记录上一层最后的节点 2. curLayerLastNode 记录当前层最后的节点 （当前层意味着正在将孩子节点加入队列，本题用linkedList实现） 解题代码：（Java） public class Solution { public ArrayList < ArrayList < Integer >> Print ( TreeNode root ) { ArrayList < ArrayList < Integer >> resLists = new ArrayList < ArrayList < Integer >>(); if ( root == null ) return resLists ; ArrayList < Integer > resList = new ArrayList < Integer >(); LinkedList < TreeNode > queue = new LinkedList < TreeNode >(); TreeNode preLayerLastNode = root ; // pre layer last node TreeNode curLayerLastNode = root ; // current layer last node boolean leftToRight = true ; // Flag using to control print order queue . offer ( root ); while (! queue . isEmpty ()){ TreeNode curNode = queue . poll (); if ( curNode . left != null ){ queue . offer ( curNode . left ); curLayerLastNode = queue . getLast (); } if ( curNode . right != null ){ queue . offer ( curNode . right ); curLayerLastNode = queue . getLast (); } if ( curNode == preLayerLastNode ){ // add // add resList to resLists and create a new resList resList . add ( curNode . val ); if ( leftToRight ) resLists . add ( resList ); else { Collections . reverse ( resList ); resLists . add ( resList ); } preLayerLastNode = curLayerLastNode ; resList = new ArrayList < Integer >(); leftToRight = ! leftToRight ; } else { resList . add ( curNode . val ); } } return resLists ; } } 060-把二叉树打印成多行 （层序遍历，逐层打印） √ 题目描述 : 从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。 思路：层序遍历 + 层最后节点判定 参考： 二叉树逐层遍历打印 解题代码：（java） import java.util.ArrayList ; import java.util.LinkedList ; /* public class TreeNode { int val = 0 ; TreeNode left = null ; TreeNode right = null ; public TreeNode ( int val ) { this . val = val ; } } */ public class Solution { ArrayList < ArrayList < Integer > > Print ( TreeNode root ) { ArrayList < ArrayList < Integer >> resLists = new ArrayList < ArrayList < Integer >> (); if ( root == null ) return resLists ; ArrayList < Integer > resList = new ArrayList < Integer > (); LinkedList < TreeNode > queue = new LinkedList < TreeNode > (); TreeNode preLayerLastNode = root ; // pre layer last node TreeNode curLayerLastNode = root ; // current layer last node queue . offer ( root ); while ( ! queue . isEmpty ()){ TreeNode curNode = queue . poll (); if ( curNode . left != null ){ queue . offer ( curNode . left ); curLayerLastNode = queue . getLast (); } if ( curNode . right != null ){ queue . offer ( curNode . right ); curLayerLastNode = queue . getLast (); } if ( curNode == preLayerLastNode ){ // add resList to resLists and create a new resList resList . add ( curNode . val ); resLists . add ( resList ); preLayerLastNode = curLayerLastNode ; resList = new ArrayList < Integer > (); } else { resList . add ( curNode . val ); } } return resLists ; } } 061-序列化二叉树 √ 题目描述 : 请实现两个函数，分别用来序列化和反序列化二叉树 二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。 二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。 思路： 1. 序列化是前序遍历的变形，加入到一个String中 2. 反序列化也是前序遍历的变形，利用一个LinkedList or Queue结构存储node vals 构造Tree 解题代码：（java） import java.util.LinkedList ; import java.util.Queue ; public class Solution { String Serialize ( TreeNode root ) { if ( root == null ){ return \"#!\" ; } String res = root . val + \"!\" ; res += Serialize ( root . left ); res += Serialize ( root . right ); return res ; } TreeNode Deserialize ( String str ) { String [] nodes = str . split ( \"!\" ); Queue < String > queue = new LinkedList < String > (); for ( int i = 0 ; i < nodes . length ; i ++ ){ queue . offer ( nodes [ i ]); } return DeserialTreeByPreOrder ( queue ); } TreeNode DeserialTreeByPreOrder ( Queue < String > queue ) { String node = queue . poll (); if ( node . equals ( \"#\" )) return null ; TreeNode head = new TreeNode ( Integer . valueOf ( node )); head . left = DeserialTreeByPreOrder ( queue ); head . right = DeserialTreeByPreOrder ( queue ); return head ; } } 062-二叉搜索树的第k个结点 √ 题目描述: 给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）中，按结点数值大小顺序第三小结点的值为4。 解题代码： public class Solution { int n = 0 ; TreeNode res = null ; TreeNode KthNode ( TreeNode pRoot , int k ) { if ( pRoot == null ) return null ; KthNode ( pRoot . left , k ) ; n += 1 ; if ( n == k ) res = pRoot ; KthNode ( pRoot . left , k ) ; return res ; } } 解题代码2：（Java） public class Solution { int n = 0 ; TreeNode res = null ; TreeNode KthNode ( TreeNode pRoot , int k ) { if ( pRoot == null ) return null ; if ( pRoot . left != null ){ KthNode ( pRoot . left , k ); } n ++; if ( n == k ){ res = pRoot ; } if ( pRoot . right != null ){ KthNode ( pRoot . right , k ); } return res ; } }","tags":"interview","url":"/20190926-Tree.html","loc":"/20190926-Tree.html"},{"title":"剑指offer|解题代码-1-LinkedList","text":"目录： [toc] LinkedList 003-从尾到头打印链表 √ 题目描述: 输入一个链表，按链表从尾到头的顺序返回一个ArrayList。 思路：所以逆序的操作都应该想到 stack 这个先进后出的数据结构 建立一个辅助栈 stack 和一个存储结构 ArrayList 将 原来链表中的值 一个个 push到 stack中 将 stack中存储的值 一个个 pop 到 ArrayList 解题代码：（Java） /** * Q : 输入一个链表，按链表从尾到头的顺序返回一个 ArrayList 。 * public class ListNode { * int val ; * ListNode next = null ; * * ListNode ( int val ) { * this . val = val ; * } * } * */ import java.util.ArrayList ; import java.util.Stack ; public class Solution { public ArrayList < Integer > printListFromTailToHead ( ListNode listNode ) { // 0. special case [] if ( listNode == null ){ ArrayList list = new ArrayList (); return list ; } // 1. Create assistant Stack and new ListNode for store data Stack < Integer > temp = new Stack <> (); ArrayList < Integer > newList = new ArrayList <> (); ListNode t = listNode ; // 2. push to Stack in order while ( t != null ){ temp . push ( t . val ); t = t . next ; } // 3. pop to new list in order which reversed order while ( ! temp . isEmpty ()){ // check whether stack is empty ? ---> . isEmpty () newList . add ( temp . pop ()); } return newList ; } } 014-链表中倒数第k个结点 √ 题目描述: 输入一个链表，输出该链表中倒数第k个结点。 思路： 快慢指针 1. 定义两个指针 P1 P2 2. P1 先向后寻址 k-1 次 3. P1 P2同时向后寻址，当P1 == NULL 时，P2所指向的恰好为倒数第k个结点 解题代码：（Java） /* public class ListNode { int val; ListNode next = null; ListNode(int val) { this.val = val; } }*/ /* 思路： 定义两个指针 P1 P2 P1 先向后寻址 k-1 次 然后P1 P2同时向后寻址，当P1 == NULL 时，P2所指向的恰好为倒数第k个结点 */ public class Solution { public ListNode FindKthToTail ( ListNode head , int k ) { if ( head == null || k <= 0 ) return null ; ListNode P1 = head ; ListNode P2 = head ; for ( int i = 0 ; i < k - 1 ; i ++){ if ( P1 . next != null ) P1 = P1 . next ; else return null ; } while ( P1 . next != null ){ P1 = P1 . next ; P2 = P2 . next ; } return P2 ; } } 015-反转链表 √ Q：输入一个链表，反转链表后，输出新链表的表头。 思路： 1. 找到反转后链表的 headNode 当cur.next == null 时， headNode = cur 2. 保证反转链表不出现断裂， 保存好 cur.next 结点 解题代码：（Java） */ public class Solution { public ListNode ReverseList ( ListNode head ) { ListNode pReversedHead = null ; ListNode pCur = head ; ListNode pPrev = null ; while ( pCur != null ){ ListNode pNext = pCur . next ; if ( pNext == null ) pReversedHead = pCur ; pCur . next = pPrev ; // 反向链表 的 Next 是之前的上一个结点 prev pPrev = pCur ; // 反向链表现在的节点 是之后的 prev节点 pCur = pNext ; } return pReversedHead ; } } 016-合并两个或k个有序链表 √ 题目描述: 输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 思路： 解题代码：（Java） 递归版本 /* public class ListNode { int val; ListNode next = null; ListNode(int val) { this.val = val; } }*/ public class Solution { // 递归版本 public ListNode Merge ( ListNode list1 , ListNode list2 ) { if ( list1 == null ) return list2 ; if ( list2 == null ) return list1 ; if ( list1 . val <= list2 . val ){ list1 . next = Merge ( list1 . next , list2 ); return list1 ; } else { list2 . next = Merge ( list1 , list2 . next ); return list2 ; } } } 非递归版本 /* public class ListNode { int val; ListNode next = null; ListNode(int val) { this.val = val; } }*/ public class Solution { // 非递归版本 public ListNode Merge ( ListNode list1 , ListNode list2 ) { if ( list1 == null ) return list2 ; if ( list2 == null ) return list1 ; ListNode list3 = new ListNode (- 1 ); ListNode head3 = list3 ; while ( list1 != null && list2 != null ){ if ( list1 . val <= list2 . val ){ list3 . val = list1 . val ; list1 = list1 . next ; } else { list3 . val = list2 . val ; list2 = list2 . next ; } list3 = list3 . next ; } while ( list1 != null ){ list3 . val = list1 . val ; list1 = list1 . next ; list3 = list3 . next ; } while ( list2 != null ){ list3 . val = list2 . val ; list2 = list2 . next ; list3 = list3 . next ; } return head3 ; // 报错 java.lang.NullPointerException } } 025-复杂链表的复制 题目描述: 输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空） 思路： 时间和空间效率最高的解法是复制+拆分 1. 复制原节点A后的A'放在A节点后 2. 遍历原节点A的random节点B，并将复制节点A'的random节点连接节点B' 3. 将链表拆分成 A->B>C 与 A'->B'->C' 解题代码：（Java） /* public class RandomListNode { int label; RandomListNode next = null; RandomListNode random = null; RandomListNode(int label) { this.label = label; } } */ /* public class Solution { public RandomListNode Clone(RandomListNode pHead) { // 0. 空链表情况 if (pHead == null){ return null; } // 1. 复制原节点A后的A'放在A节点后 RandomListNode cur = pHead; while(cur !=null){ RandomListNode repeat = new RandomListNode(cur.label); repeat.next = cur.next; cur.next = repeat; cur = cur.next; } //2. 遍历原节点A的random节点B，并将复制节点A'的random节点连接节点B' cur = pHead; while(cur != null){ cur.next.random = cur.random.next; // 自己画个图比较好理解 cur = cur.next.next; } // 3. 将链表拆分成 A->B>C 与 A'->B'->C' cur = pHead; // A RandomListNode newHead = pHead.next; // A' //RandomListNode newCur = newHead;//A' while(cur !=null){ RandomListNode cloneNode = cur.next;//A' cur.next = cur.next.next; // A -> B cloneNode.next = cloneNode.next.next;// A'->B' cur = cur.next;// A ---> B } return newHead; } } 036-两个链表的第一个公共结点 √ 题目描述: 输入两个链表，找出它们的第一个公共结点。 Date: 20190918 思路： 首先，存在公共结点的两个链表是Y字形的，而不可能出现X形的，意味着从第一个公共结点开始，它们的后续结点都相同。 1. 计算两个List的长度，得到长度查Dif 2. 长的List 先遍历 Dif次后，与短的List依次比较结点 3. 当结点相同，则为第一个公共结点 解题代码：（Java） /* public class ListNode { int val; ListNode next = null; ListNode(int val) { this.val = val; } }*/ public class Solution { public ListNode FindFirstCommonNode ( ListNode pHead1 , ListNode pHead2 ) { if ( pHead1 == null || pHead2 == null ){ return null ; } ListNode cur1 = pHead1 ; ListNode cur2 = pHead2 ; int pHead1Length = 0 ; int pHead2Length = 0 ; while ( cur1 != null ){ pHead1Length ++; cur1 = cur1 . next ; } while ( cur2 != null ){ pHead2Length ++; cur2 = cur2 . next ; } cur1 = pHead1 ; cur2 = pHead2 ; if ( pHead1Length >= pHead2Length ){ int lengthDif = pHead1Length - pHead2Length ; while ( lengthDif > 0 ){ cur1 = cur1 . next ; lengthDif --; } } else { int lengthDif = pHead2Length - pHead1Length ; while ( lengthDif > 0 ){ cur2 = cur2 . next ; lengthDif --; } } while ( cur1 != null && cur2 != null && cur1 != cur2 ){ cur1 = cur1 . next ; cur2 = cur2 . next ; } return cur1 ; } } 055-链表中环的入口结点 √ 题目描述: 给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。 思路： 1. 快慢指针，直到相遇 2. 慢指针回到head，快指针速度降为一次一步，再次相遇则为环入口 3. 需要注意快指针的边界和测试用例的情况 解题代码：（java） /* public class ListNode { int val; ListNode next = null; ListNode(int val) { this.val = val; } } */ /* 思路： 1. 快慢指针，直到相遇 2. 慢指针回到head，快指针速度降为一次一步，再次相遇则为环入口 3. 需要注意快指针的边界和测试用例的情况 */ public class Solution { public ListNode EntryNodeOfLoop ( ListNode pHead ) { if ( pHead == null || pHead . next == null ) return null ; ListNode pFast = pHead ; ListNode pSlow = pHead ; while ( pFast != null && pFast . next != null ){ pFast = pFast . next . next ; pSlow = pSlow . next ; if ( pFast == pSlow ){ pSlow = pHead ; while ( pFast != pSlow ){ pFast = pFast . next ; pSlow = pSlow . next ; } if ( pFast == pSlow ) return pFast ; } } return pSlow ; } } 056-删除链表中重复的结点 √ 题目描述 : 在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1->2->3->3->4->4->5 处理后为 1->2->5 思路: 1. 创建头结点，解决 1-1-2-2-3-3 这种一开始就遇到一样的问题 2. 创建preNode 确定前一个不重复的结点 3. 创建curNode 一直遍历，遇到重复的结点（值相同）就继续往后， 若值不相同，令preNode.next 指向 curNode.next curNode = curNode.next 解题代码：（Java） /* public class ListNode { int val; ListNode next = null; ListNode(int val) { this.val = val; } } */ /* 思路: 1. 创建头结点，解决 1-1-2-2-3-3 这种一开始就遇到一样的问题 2. 创建preNode 确定前一个不重复的结点 3. 创建curNode 一直遍历，遇到重复的结点（值相同）就继续往后， 若值不相同，令preNode.next 指向 curNode.next curNode = curNode.next */ public class Solution { public ListNode deleteDuplication ( ListNode pHead ) { ListNode headNode = new ListNode ( 0 ); headNode . next = pHead ; ListNode preNode = headNode ; ListNode curNode = pHead ; while ( curNode != null ){ // move and delete if ( curNode . next != null && curNode . val == curNode . next . val ){ while ( curNode . next != null && curNode . val == curNode . next . val ){ curNode = curNode . next ; } preNode . next = curNode . next ; curNode = curNode . next ; } // move else { preNode = curNode ; curNode = curNode . next ; } } return headNode . next ; } }","tags":"interview","url":"/20190919-LinkedList.html","loc":"/20190919-LinkedList.html"},{"title":"剑指offer|题库目录","text":"目录： [toc] LinkedList 003-从尾到头打印链表 014-链表中倒数第k个结点 015-反转链表 016-合并两个或k个有序链表 025-复杂链表的复制 036-两个链表的第一个公共结点 055-链表中环的入口结点 056-删除链表中重复的结点 Tree 004-重建二叉树 017-树的子结构 018-二叉树的镜像 022-从上往下打印二叉树 023-二叉搜索树的后序遍历序列 024-二叉树中和为某一值的路径 026-二叉搜索树与双向链表 038-二叉树的深度 039-平衡二叉树 057-二叉树的下一个结点 058-对称的二叉树 059-按之字形顺序打印二叉树 060-把二叉树打印成多行 061-序列化二叉树 062-二叉搜索树的第k个结点 Stack & Queue 005-用两个栈实现队列 020-包含min函数的栈 021-栈的压入、弹出序列 044-翻转单词顺序列(栈) 064-滑动窗口的最大值(双端队列) Heap 029-最小的K个数 Hash Table 034-第一个只出现一次的字符 图 065-矩阵中的路径(BFS) 066-机器人的运动范围(DFS) 其他算法 002-替换空格 013-调整数组顺序使奇数位于偶数前面 028-数组中出现次数超过一半的数字 031-整数中1出现的次数（从1到n整数中1出现的次数） 032-把数组排成最小的数 033-丑数 041-和为S的连续正数序列(滑动窗口思想) 042-和为S的两个数字(双指针思想) 043-左旋转字符串(矩阵翻转) 046-孩子们的游戏-圆圈中最后剩下的数(约瑟夫环) 051-构建乘积数组 References： 知乎专栏：sjz的学习和随想管理专栏写文章","tags":"interview","url":"/20190913剑指offer题库目录.html","loc":"/20190913剑指offer题库目录.html"},{"title":"2019-02-10左神算法课初级2笔记","text":"[toc] 初级2 题一 给定一个数组arr，和一个数num，请把小于等于num的数放在数 组的左边，大于num的数放在数组的右边。 要求额外空间复杂度O(1)，时间复杂度O(N) 思路 小于等于num区域 和 大于num区域 两个指针： 1. 一个 less --- 小于等于区最后一位 2. 一个 cur --- 当前遍历位置 荷兰国旗问题 给定一个数组arr，和一个数num，请把小于num的数放在数组的 左边，等于num的数放在数组的中间，大于num的数放在数组的 右边。 要求额外空间复杂度O(1)，时间复杂度O(N) 多加 等于区 and 大于区 快速排序 数组算法设计核心 指针移动 边界条件 工业界几乎不会允许递归实现出现，任何递归函数都一定可以转化成为非递归实现 堆 Heap 时间复杂度 O(N * logN) 额外空间复杂度 O(1) 堆结构 分清楚满二叉树，完全二叉树的区别 --- 堆是完全二叉树 具体实现用数组结构，但是我们可以逻辑上想象成一个二叉树 说到堆一定是有隐藏条件的 --- 大根堆 or 小根堆 大根堆 --- 任何子树中， 父节点 > 子节点 小跟堆 --- 任何子树中， 父节点 < 子节点 堆结构操作 heapInsert --- 增加一个新的节点操作 public static void heapInsert ( int [] arr , int index ) { while ( arr [ index ] > arr [( index - 1 ) / 2 ]) { swap ( arr , index , ( index - 1 ) / 2 ); index = ( index - 1 ) / 2 ; } } heapify --- 更新节点操作 public static void heapify ( int [] arr , int index , int size ) { int left = index * 2 + 1 ; while ( left < size ) { int largest = left + 1 < size && arr [ left + 1 ] > arr [ left ] ? left + 1 : left ; largest = arr [ largest ] > arr [ index ] ? largest : index ; if ( largest == index ) { break ; } swap ( arr , largest , index ); index = largest ; left = index * 2 + 1 ; } } 堆排序 排序算法稳定性 定义： 排序结果中，相同值的原始次序不会改变 意义： 保存原始排序中的信息，例如最开始是按照年龄排好序的一组数据，现在想要再对身高进行排序，这时如果排序算法稳定，则按照身高排好序的结果中，相同身高的数据项年龄依然保持原来的有序状态 快速排序和堆排序都是 不稳定的 一道坑爹的面试题： 能否将一个数组排序成，奇数放左边，偶数放右边，相对次序不改变 要求：时间复杂度为O(N),额外空间复杂度为O(1) 回答：做不到，因为奇偶和大于小于本质一样，都是一种 01标准 ，不是0就是1 这两个要求的条件本质和荷兰国旗问题的划分一样，所以这个问题等价于问我快速排序能不能够做到稳定。 比较器 comparator 本质；到底要求怎么排序？基于比较器就很好写代码了 例如，结构体排序时根据什么来排呢？ 例如，结构体中 Tips：面试技巧 分清楚压力面试还是故意刁难。 压力面试 --- 问题很尖锐，不给喘息时间，但是态度往往很端正，不会给你出了压力以外的负面情绪 故意刁难 --- 态度很不端正，摆架子，阴阳怪气，而且自己问的问题自己都没有认真准备答案 工业上的排序算法实现 当长度小于 60 时，直接用插入排序，因为常数项极低，而且O(N&#94;2)此时的劣势表现并不明显 当所排序的数组是基础类型 （byte，short，int，double，float）， 相同数据之间次序无所谓 ，直接用 快排 当所排序的数组是自己定义的结构体类型（student）里面带有多维信息，则用 归并排序 ，保持稳定 其他排序 --- 不基于比较的排序 特点： 受自身数据状况的影响太大 1 桶排序概念 桶是什么？ 一种表示各个数据出现频率的容器 计数排序 一个存储数据（词频）的容器，然后基于这个桶容器把所有数据统计一遍成为词频后（各个数据出现的次数）重新生成一组新的数据，所有过程没有进行过一次比较 经典题目： 给定一个数组，求如果排序之后，相邻两数的最大差值，要求时 间复杂度O(N)，且要求不能用非基于比较的排序 思路：N个数，分配N+1个桶（0~N），先遍历一遍找出最大值和最小值（max and min），min 放在0号桶，max 放在 N号桶，将剩下的N-1个桶均分成等大小的，放入剩下的 N-2个元素，那么必然至少会存在一个空桶。这样做完之后，我们可以排除一个可能性 ： 相邻两数的最大差值一定不会来自于同一个桶中的两个数，一定是来自不同桶的。 实现： 利用三个长度为 N+1 的数组 表示桶中的三个变量 int minList[],int maxList[],boolean isEmptyList[] 遍历每相邻两个桶的最值差： if !isEmptyList[i]： MaxGap = minList[i+1] - maxList[i]","tags":"study","url":"/20190210.html","loc":"/20190210.html"},{"title":"first_post","text":"Why everyone should have his own tech-blog? 1. Remark 2. Improve 3. Review","tags":"study","url":"/first_post.html","loc":"/first_post.html"}]};