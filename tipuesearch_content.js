var tipuesearch = {"pages":[{"title":"About me","text":"Hello, this is 单金哲(Jinzhe Shan). You can find me at LinkedIn . You can alse feel free to email me at any time.","tags":"pages","url":"/about","loc":"/about"},{"title":"剑指offer|解题代码-1-LinkedList","text":"目录： [toc] LinkedList 003-从尾到头打印链表 √ 题目描述: 输入一个链表，按链表从尾到头的顺序返回一个ArrayList。 思路：所以逆序的操作都应该想到 stack 这个先进后出的数据结构 建立一个辅助栈 stack 和一个存储结构 ArrayList 将 原来链表中的值 一个个 push到 stack中 将 stack中存储的值 一个个 pop 到 ArrayList 解题代码：（Java） /** * Q : 输入一个链表，按链表从尾到头的顺序返回一个 ArrayList 。 * public class ListNode { * int val ; * ListNode next = null ; * * ListNode ( int val ) { * this . val = val ; * } * } * */ import java.util.ArrayList ; import java.util.Stack ; public class Solution { public ArrayList < Integer > printListFromTailToHead ( ListNode listNode ) { // 0. special case [] if ( listNode == null ){ ArrayList list = new ArrayList (); return list ; } // 1. Create assistant Stack and new ListNode for store data Stack < Integer > temp = new Stack <> (); ArrayList < Integer > newList = new ArrayList <> (); ListNode t = listNode ; // 2. push to Stack in order while ( t != null ){ temp . push ( t . val ); t = t . next ; } // 3. pop to new list in order which reversed order while ( ! temp . isEmpty ()){ // check whether stack is empty ? ---> . isEmpty () newList . add ( temp . pop ()); } return newList ; } } 014-链表中倒数第k个结点 √ 题目描述: 输入一个链表，输出该链表中倒数第k个结点。 思路： 快慢指针 1. 定义两个指针 P1 P2 2. P1 先向后寻址 k-1 次 3. P1 P2同时向后寻址，当P1 == NULL 时，P2所指向的恰好为倒数第k个结点 解题代码：（Java） /* public class ListNode { int val; ListNode next = null; ListNode(int val) { this.val = val; } }*/ /* 思路： 定义两个指针 P1 P2 P1 先向后寻址 k-1 次 然后P1 P2同时向后寻址，当P1 == NULL 时，P2所指向的恰好为倒数第k个结点 */ public class Solution { public ListNode FindKthToTail ( ListNode head , int k ) { if ( head == null || k <= 0 ) return null ; ListNode P1 = head ; ListNode P2 = head ; for ( int i = 0 ; i < k - 1 ; i ++){ if ( P1 . next != null ) P1 = P1 . next ; else return null ; } while ( P1 . next != null ){ P1 = P1 . next ; P2 = P2 . next ; } return P2 ; } } 015-反转链表 √ Q：输入一个链表，反转链表后，输出新链表的表头。 思路： 1. 找到反转后链表的 headNode 当cur.next == null 时， headNode = cur 2. 保证反转链表不出现断裂， 保存好 cur.next 结点 解题代码：（Java） */ public class Solution { public ListNode ReverseList ( ListNode head ) { ListNode pReversedHead = null ; ListNode pCur = head ; ListNode pPrev = null ; while ( pCur != null ){ ListNode pNext = pCur . next ; if ( pNext == null ) pReversedHead = pCur ; pCur . next = pPrev ; // 反向链表 的 Next 是之前的上一个结点 prev pPrev = pCur ; // 反向链表现在的节点 是之后的 prev节点 pCur = pNext ; } return pReversedHead ; } } 016-合并两个或k个有序链表 √ 题目描述: 输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 思路： 解题代码：（Java） 递归版本 /* public class ListNode { int val; ListNode next = null; ListNode(int val) { this.val = val; } }*/ public class Solution { // 递归版本 public ListNode Merge ( ListNode list1 , ListNode list2 ) { if ( list1 == null ) return list2 ; if ( list2 == null ) return list1 ; if ( list1 . val <= list2 . val ){ list1 . next = Merge ( list1 . next , list2 ); return list1 ; } else { list2 . next = Merge ( list1 , list2 . next ); return list2 ; } } } 非递归版本 /* public class ListNode { int val; ListNode next = null; ListNode(int val) { this.val = val; } }*/ public class Solution { // 非递归版本 public ListNode Merge ( ListNode list1 , ListNode list2 ) { if ( list1 == null ) return list2 ; if ( list2 == null ) return list1 ; ListNode list3 = new ListNode (- 1 ); ListNode head3 = list3 ; while ( list1 != null && list2 != null ){ if ( list1 . val <= list2 . val ){ list3 . val = list1 . val ; list1 = list1 . next ; } else { list3 . val = list2 . val ; list2 = list2 . next ; } list3 = list3 . next ; } while ( list1 != null ){ list3 . val = list1 . val ; list1 = list1 . next ; list3 = list3 . next ; } while ( list2 != null ){ list3 . val = list2 . val ; list2 = list2 . next ; list3 = list3 . next ; } return head3 ; // 报错 java.lang.NullPointerException } } 025-复杂链表的复制 题目描述: 输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空） 思路： 时间和空间效率最高的解法是复制+拆分 1. 复制原节点A后的A'放在A节点后 2. 遍历原节点A的random节点B，并将复制节点A'的random节点连接节点B' 3. 将链表拆分成 A->B>C 与 A'->B'->C' 解题代码：（Java） /* public class RandomListNode { int label; RandomListNode next = null; RandomListNode random = null; RandomListNode(int label) { this.label = label; } } */ /* public class Solution { public RandomListNode Clone(RandomListNode pHead) { // 0. 空链表情况 if (pHead == null){ return null; } // 1. 复制原节点A后的A'放在A节点后 RandomListNode cur = pHead; while(cur !=null){ RandomListNode repeat = new RandomListNode(cur.label); repeat.next = cur.next; cur.next = repeat; cur = cur.next; } //2. 遍历原节点A的random节点B，并将复制节点A'的random节点连接节点B' cur = pHead; while(cur != null){ cur.next.random = cur.random.next; // 自己画个图比较好理解 cur = cur.next.next; } // 3. 将链表拆分成 A->B>C 与 A'->B'->C' cur = pHead; // A RandomListNode newHead = pHead.next; // A' //RandomListNode newCur = newHead;//A' while(cur !=null){ RandomListNode cloneNode = cur.next;//A' cur.next = cur.next.next; // A -> B cloneNode.next = cloneNode.next.next;// A'->B' cur = cur.next;// A ---> B } return newHead; } } 036-两个链表的第一个公共结点 √ 题目描述: 输入两个链表，找出它们的第一个公共结点。 Date: 20190918 思路： 首先，存在公共结点的两个链表是Y字形的，而不可能出现X形的，意味着从第一个公共结点开始，它们的后续结点都相同。 1. 计算两个List的长度，得到长度查Dif 2. 长的List 先遍历 Dif次后，与短的List依次比较结点 3. 当结点相同，则为第一个公共结点 解题代码：（Java） /* public class ListNode { int val; ListNode next = null; ListNode(int val) { this.val = val; } }*/ public class Solution { public ListNode FindFirstCommonNode ( ListNode pHead1 , ListNode pHead2 ) { if ( pHead1 == null || pHead2 == null ){ return null ; } ListNode cur1 = pHead1 ; ListNode cur2 = pHead2 ; int pHead1Length = 0 ; int pHead2Length = 0 ; while ( cur1 != null ){ pHead1Length ++; cur1 = cur1 . next ; } while ( cur2 != null ){ pHead2Length ++; cur2 = cur2 . next ; } cur1 = pHead1 ; cur2 = pHead2 ; if ( pHead1Length >= pHead2Length ){ int lengthDif = pHead1Length - pHead2Length ; while ( lengthDif > 0 ){ cur1 = cur1 . next ; lengthDif --; } } else { int lengthDif = pHead2Length - pHead1Length ; while ( lengthDif > 0 ){ cur2 = cur2 . next ; lengthDif --; } } while ( cur1 != null && cur2 != null && cur1 != cur2 ){ cur1 = cur1 . next ; cur2 = cur2 . next ; } return cur1 ; } } 055-链表中环的入口结点 √ 题目描述: 给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。 思路： 1. 快慢指针，直到相遇 2. 慢指针回到head，快指针速度降为一次一步，再次相遇则为环入口 3. 需要注意快指针的边界和测试用例的情况 解题代码：（java） /* public class ListNode { int val; ListNode next = null; ListNode(int val) { this.val = val; } } */ /* 思路： 1. 快慢指针，直到相遇 2. 慢指针回到head，快指针速度降为一次一步，再次相遇则为环入口 3. 需要注意快指针的边界和测试用例的情况 */ public class Solution { public ListNode EntryNodeOfLoop ( ListNode pHead ) { if ( pHead == null || pHead . next == null ) return null ; ListNode pFast = pHead ; ListNode pSlow = pHead ; while ( pFast != null && pFast . next != null ){ pFast = pFast . next . next ; pSlow = pSlow . next ; if ( pFast == pSlow ){ pSlow = pHead ; while ( pFast != pSlow ){ pFast = pFast . next ; pSlow = pSlow . next ; } if ( pFast == pSlow ) return pFast ; } } return pSlow ; } } 056-删除链表中重复的结点 √ 题目描述 : 在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1->2->3->3->4->4->5 处理后为 1->2->5 思路: 1. 创建头结点，解决 1-1-2-2-3-3 这种一开始就遇到一样的问题 2. 创建preNode 确定前一个不重复的结点 3. 创建curNode 一直遍历，遇到重复的结点（值相同）就继续往后， 若值不相同，令preNode.next 指向 curNode.next curNode = curNode.next 解题代码：（Java） /* public class ListNode { int val; ListNode next = null; ListNode(int val) { this.val = val; } } */ /* 思路: 1. 创建头结点，解决 1-1-2-2-3-3 这种一开始就遇到一样的问题 2. 创建preNode 确定前一个不重复的结点 3. 创建curNode 一直遍历，遇到重复的结点（值相同）就继续往后， 若值不相同，令preNode.next 指向 curNode.next curNode = curNode.next */ public class Solution { public ListNode deleteDuplication ( ListNode pHead ) { ListNode headNode = new ListNode ( 0 ); headNode . next = pHead ; ListNode preNode = headNode ; ListNode curNode = pHead ; while ( curNode != null ){ // move and delete if ( curNode . next != null && curNode . val == curNode . next . val ){ while ( curNode . next != null && curNode . val == curNode . next . val ){ curNode = curNode . next ; } preNode . next = curNode . next ; curNode = curNode . next ; } // move else { preNode = curNode ; curNode = curNode . next ; } } return headNode . next ; } }","tags":"interview","url":"/20190919-LinkedList.html","loc":"/20190919-LinkedList.html"},{"title":"剑指offer|题库目录","text":"目录： [toc] LinkedList 003-从尾到头打印链表 014-链表中倒数第k个结点 015-反转链表 016-合并两个或k个有序链表 025-复杂链表的复制 036-两个链表的第一个公共结点 055-链表中环的入口结点 056-删除链表中重复的结点 Tree 004-重建二叉树 017-树的子结构 018-二叉树的镜像 022-从上往下打印二叉树 023-二叉搜索树的后序遍历序列 024-二叉树中和为某一值的路径 026-二叉搜索树与双向链表 038-二叉树的深度 039-平衡二叉树 057-二叉树的下一个结点 058-对称的二叉树 059-按之字形顺序打印二叉树 060-把二叉树打印成多行 061-序列化二叉树 062-二叉搜索树的第k个结点 Stack & Queue 005-用两个栈实现队列 020-包含min函数的栈 021-栈的压入、弹出序列 044-翻转单词顺序列(栈) 064-滑动窗口的最大值(双端队列) Heap 029-最小的K个数 Hash Table 034-第一个只出现一次的字符 图 065-矩阵中的路径(BFS) 066-机器人的运动范围(DFS) 其他算法 002-替换空格 013-调整数组顺序使奇数位于偶数前面 028-数组中出现次数超过一半的数字 031-整数中1出现的次数（从1到n整数中1出现的次数） 032-把数组排成最小的数 033-丑数 041-和为S的连续正数序列(滑动窗口思想) 042-和为S的两个数字(双指针思想) 043-左旋转字符串(矩阵翻转) 046-孩子们的游戏-圆圈中最后剩下的数(约瑟夫环) 051-构建乘积数组 References： 知乎专栏：sjz的学习和随想管理专栏写文章","tags":"interview","url":"/20190913剑指offer题库目录.html","loc":"/20190913剑指offer题库目录.html"},{"title":"2019-02-10左神算法课初级2笔记","text":"[toc] 初级2 题一 给定一个数组arr，和一个数num，请把小于等于num的数放在数 组的左边，大于num的数放在数组的右边。 要求额外空间复杂度O(1)，时间复杂度O(N) 思路 小于等于num区域 和 大于num区域 两个指针： 1. 一个 less --- 小于等于区最后一位 2. 一个 cur --- 当前遍历位置 荷兰国旗问题 给定一个数组arr，和一个数num，请把小于num的数放在数组的 左边，等于num的数放在数组的中间，大于num的数放在数组的 右边。 要求额外空间复杂度O(1)，时间复杂度O(N) 多加 等于区 and 大于区 快速排序 数组算法设计核心 指针移动 边界条件 工业界几乎不会允许递归实现出现，任何递归函数都一定可以转化成为非递归实现 堆 Heap 时间复杂度 O(N * logN) 额外空间复杂度 O(1) 堆结构 分清楚满二叉树，完全二叉树的区别 --- 堆是完全二叉树 具体实现用数组结构，但是我们可以逻辑上想象成一个二叉树 说到堆一定是有隐藏条件的 --- 大根堆 or 小根堆 大根堆 --- 任何子树中， 父节点 > 子节点 小跟堆 --- 任何子树中， 父节点 < 子节点 堆结构操作 heapInsert --- 增加一个新的节点操作 public static void heapInsert ( int [] arr , int index ) { while ( arr [ index ] > arr [( index - 1 ) / 2 ]) { swap ( arr , index , ( index - 1 ) / 2 ); index = ( index - 1 ) / 2 ; } } heapify --- 更新节点操作 public static void heapify ( int [] arr , int index , int size ) { int left = index * 2 + 1 ; while ( left < size ) { int largest = left + 1 < size && arr [ left + 1 ] > arr [ left ] ? left + 1 : left ; largest = arr [ largest ] > arr [ index ] ? largest : index ; if ( largest == index ) { break ; } swap ( arr , largest , index ); index = largest ; left = index * 2 + 1 ; } } 堆排序 排序算法稳定性 定义： 排序结果中，相同值的原始次序不会改变 意义： 保存原始排序中的信息，例如最开始是按照年龄排好序的一组数据，现在想要再对身高进行排序，这时如果排序算法稳定，则按照身高排好序的结果中，相同身高的数据项年龄依然保持原来的有序状态 快速排序和堆排序都是 不稳定的 一道坑爹的面试题： 能否将一个数组排序成，奇数放左边，偶数放右边，相对次序不改变 要求：时间复杂度为O(N),额外空间复杂度为O(1) 回答：做不到，因为奇偶和大于小于本质一样，都是一种 01标准 ，不是0就是1 这两个要求的条件本质和荷兰国旗问题的划分一样，所以这个问题等价于问我快速排序能不能够做到稳定。 比较器 comparator 本质；到底要求怎么排序？基于比较器就很好写代码了 例如，结构体排序时根据什么来排呢？ 例如，结构体中 Tips：面试技巧 分清楚压力面试还是故意刁难。 压力面试 --- 问题很尖锐，不给喘息时间，但是态度往往很端正，不会给你出了压力以外的负面情绪 故意刁难 --- 态度很不端正，摆架子，阴阳怪气，而且自己问的问题自己都没有认真准备答案 工业上的排序算法实现 当长度小于 60 时，直接用插入排序，因为常数项极低，而且O(N&#94;2)此时的劣势表现并不明显 当所排序的数组是基础类型 （byte，short，int，double，float）， 相同数据之间次序无所谓 ，直接用 快排 当所排序的数组是自己定义的结构体类型（student）里面带有多维信息，则用 归并排序 ，保持稳定 其他排序 --- 不基于比较的排序 特点： 受自身数据状况的影响太大 1 桶排序概念 桶是什么？ 一种表示各个数据出现频率的容器 计数排序 一个存储数据（词频）的容器，然后基于这个桶容器把所有数据统计一遍成为词频后（各个数据出现的次数）重新生成一组新的数据，所有过程没有进行过一次比较 经典题目： 给定一个数组，求如果排序之后，相邻两数的最大差值，要求时 间复杂度O(N)，且要求不能用非基于比较的排序 思路：N个数，分配N+1个桶（0~N），先遍历一遍找出最大值和最小值（max and min），min 放在0号桶，max 放在 N号桶，将剩下的N-1个桶均分成等大小的，放入剩下的 N-2个元素，那么必然至少会存在一个空桶。这样做完之后，我们可以排除一个可能性 ： 相邻两数的最大差值一定不会来自于同一个桶中的两个数，一定是来自不同桶的。 实现： 利用三个长度为 N+1 的数组 表示桶中的三个变量 int minList[],int maxList[],boolean isEmptyList[] 遍历每相邻两个桶的最值差： if !isEmptyList[i]： MaxGap = minList[i+1] - maxList[i]","tags":"study","url":"/20190210.html","loc":"/20190210.html"},{"title":"first_post","text":"Why everyone should have his own tech-blog? 1. Remark 2. Improve 3. Review","tags":"study","url":"/first_post.html","loc":"/first_post.html"}]};