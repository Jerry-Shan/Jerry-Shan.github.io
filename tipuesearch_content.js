var tipuesearch = {"pages":[{"title":"About me","text":"Hello, this is 单金哲(Jinzhe Shan). You can find me at LinkedIn . You can alse feel free to email me at any time.","tags":"pages","url":"/about","loc":"/about"},{"title":"剑指offer|解题代码-3-Stack-Queue-Heap-HashMap-Graph(Java)","text":"目录： Stack & Queue ​ 005-用两个栈实现队列 √ ​ 020-包含min函数的栈 √ ​ 021-栈的压入、弹出序列 √ ​ 044-翻转单词顺序列(栈) √ ​ 043-左旋转字符串(矩阵翻转) √ ​ 064-滑动窗口的最大值 √ Heap ​ 029-最小的K个数 √ Hash Table ​ 034-第一个只出现一次的字符 √ 图 （图的遍历 + 回溯法） ​ 065-矩阵中的路径(BFS) √ ​ 066-机器人的运动范围(DFS) √ Stack & Queue 005-用两个栈实现队列 √ 题目描述: 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 思路： 栈 ---先入后出 ；队列 --- 先入先出 1. 一个栈负责入队，另一个负责出队，出栈为空则从入栈中导入到出栈中 2. 相当于每次弹出前，先把栈掉了一个顺序，然后再把栈尾（队头）pop出来 解题代码：（Java） import java.util.Stack ; public class Solution { Stack < Integer > stack1 = new Stack < Integer > (); Stack < Integer > stack2 = new Stack < Integer > (); public void push ( int node ) { stack1 . push ( node ); } public int pop () { if ( stack2 . empty ()){ while ( ! stack1 . empty ()){ stack2 . push ( stack1 . pop ()); } } return stack2 . pop (); } } 020-包含min函数的栈 √ 题目描述: 定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1）） 思路： 1. 因为要求时间复杂度为 O(1) 自然想到用额外空间换时间 2. 创建两个 Stack： 1 - dataStack 正常顺序存储堆栈；2 - minStack 存当前堆栈最小值 3. push时判定 新加入的 node 是否比 minStack.peek() 小，如果小则 minStack.push(node) 4. 否则 minStack.push(minStack.peek()) // 相当于新加入的node比之前的min大， minStack中存入一个之前的min值（minStack.peek()） 解题代码：（java） import java.util.Stack ; public class Solution { Stack < Integer > dataStack = new Stack < Integer >(); Stack < Integer > minStack = new Stack < Integer >(); public void push ( int node ) { dataStack . push ( node ); if ( minStack . isEmpty () || node < minStack . peek ()) minStack . push ( node ); // add the old peek value as new peak value (min value) else minStack . push ( minStack . peek ()); } public void pop () { dataStack . pop (); minStack . pop (); } // get top node value in Stack public int top () { return dataStack . peek (); } // get min node value in Stack public int min () { return minStack . peek (); } } 021-栈的压入、弹出序列 √ 题目描述 : 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 给定栈的压入序列，判断某序列是否可能为栈的弹出序列是一道笔试中常考的选择题，那么如何用代码来判定呢？ 思路: 1. 循环，找和pop序列第一个元素相同的值 - 找到，则 stack.pop()，indexPop后移 - 未找到，则 stack.push(pushA[indexPush]) 2. 退出条件：如果弹出序列指针还没到结尾但已经无元素可压入，则被测序列不是弹出序列。 3. 循环结束依然没有退出，返回 true 解题代码：（java） import java.util.Stack ; public class Solution { public boolean IsPopOrder ( int [] pushA , int [] popA ) { if ( pushA == null || popA == null || pushA . length != popA . length ) return false ; Stack < Integer > stack = new Stack < Integer > (); int indexPush = 0 ; int indexPop = 0 ; while ( indexPop < popA . length ){ // Do not find the equal value if ( stack . isEmpty () || stack . peek () != popA [ indexPop ]){ // the push sequence is not clear if ( indexPush < pushA . length ){ stack . push ( pushA [ indexPush ]); indexPush += 1 ; } else return false ; } // Find the equal value else { stack . pop (); indexPop += 1 ; } } return true ; } } 044-翻转单词顺序列(栈) √ 题目描述：句子中单词翻转，但是单词里的字母不翻转 \"student. a am I\" --> \"I am a student.\" 思路: 1. 先把整个字符串反转 2. 再将每一个单词分别反转会原状 解题代码：（java） import java.util.Stack ; public class Solution { // reverse a whole sentence but do not reverse letters in a word . public String ReverseSentence ( String str ) { // using str . trim () . equals ( \"\" ) to remove multiple space if ( str == null || str . trim () . equals ( \"\" )) return str ; String reverseStr = Reverse ( str ); String [] words = reverseStr . split ( \" \" ); StringBuffer sb = new StringBuffer (); for ( int i = 0 ; i < words . length - 1 ; i ++ ){ sb . append ( Reverse ( words [ i ]) + \" \" ); } // Note : the last word without space symbol sb . append ( Reverse ( words [ words . length - 1 ])); return sb . toString (); } public String Reverse ( String str ){ StringBuffer sb = new StringBuffer (); int index = 0 ; Stack < Character > stack = new Stack < Character > (); for (; index < str . length (); index ++ ){ stack . push ( str . charAt ( index )); } while ( ! stack . isEmpty ()){ sb . append ( stack . pop ()); } return sb . toString (); } } 043-左旋转字符串(矩阵翻转) √ 题目描述：对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=\"abcXYZdef\",要求输出循环左移3位后的结果，即\"XYZdefabc\" 思路： 1. 直接两个for循环反转就行，时间复杂度 O(n) 2. 注意当传入值 n > str.length() 时做取模操作 解题代码：（java） public class Solution { public String LeftRotateString ( String str , int n ) { if ( str == null || str . trim () . equals ( \"\" ) || n < 0 ) return str ; if ( n > str . length ()) n = n % str . length () ; StringBuffer sb = new StringBuffer () ; int i ; for ( i = n ;i<str.length();i++){ sb . append ( str . charAt ( i )) ; } for ( i = 0 ;i<n;i++){ sb . append ( str . charAt ( i )) ; } return sb . toString () ; } } 064-滑动窗口的最大值 √ 题目描述 : 给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5} 解法1 - 暴力循环法 时间复杂度 O(n*size)，空间复杂度O(1) 解题代码 （Java）： import java.util.ArrayList ; public class Solution { public ArrayList < Integer > maxInWindows ( int [] num , int size ) { ArrayList < Integer > res = new ArrayList < Integer > (); if ( num . length <= 0 || size <= 0 ) return res ; int i = 0 ; for (; i < num . length ; i ++ ){ int j = 1 ; int max = num [ i ]; for (; j < size && j + i < num . length ; j ++ ){ if ( num [ i + j ] > max ) max = num [ i + j ]; } // avoid beyond the range if ( size + i < num . length + 1 ) res . add ( max ); } return res ; } } [ ] 解法2 - 双端队列 待补充 解题代码：（java） Heap 029-最小的K个数 *** √ 题目描述 ： 输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。 这是典型的TopK问题，常见的几种解法有： 1. 全排序，然后取出前K位。但是这在数据量很大的情况下很明显是做了后K位数字排序的无用功。时间复杂度为O(n logn),空间复杂度为O(1) 2. 堆排序，创建一个长度为K的堆，TopMaxK则用最大堆，TopMinK则用最小堆，并且不会更改原数组，适合处理海量数据情况。时间复杂度为O(n logk),空间复杂度为O(k) 解题代码 1-优先级实现 minHeap：（java） import java.util.PriorityQueue ; import java.util.ArrayList ; public class Solution { public ArrayList < Integer > GetLeastNumbers_Solution ( int [] input , int k ) { if ( k > input . length || k <= 0 ) return new ArrayList <> (); // Max Heap // PriorityQueue < Integer > maxHeap = new PriorityQueue <> (); // Min Heap PriorityQueue < Integer > minHeap = new PriorityQueue <> (( o1 , o2 ) -> o2 - o1 ); for ( int num : input ) { minHeap . add ( num ); if ( minHeap . size () > k ) minHeap . poll (); } return new ArrayList <> ( minHeap ); } } [ ] 解题代码 2-手撸Heap ：（java） Hash Table 034-第一个只出现一次的字符 √ 题目描述 : 在一个字符串(0<=字符串长度<=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）. 思路：利用一个额外数组times[char]存储str中不同字符的个数，顺序存储第二次扫描时遇到的第一个 times[char] == 1 的 char所在str中的index即为答案 解题代码 1- int [] （java）： public class T34_FirstNotRepeatingChar { public int FirstNotRepeatingChar ( String str ) { if ( str == null ) return - 1 ; int [] times = new int [ 256 ] ; for ( int i = 0 ; i<str.length();i++){ System . out . println ( str . charAt ( i )) ; times [ str . charAt ( i ) ] += 1 ; } for ( int i = 0 ; i<str.length();i++){ System . out . println ( str . charAt ( i ) + \" : \" + times [ str . charAt ( i ) ] ) ; if ( times [ str . charAt ( i ) ] == 1 ) return str . indexOf ( str . charAt ( i )) ; } return - 1 ; } } 解题代码 2- HashMap (Java): import java.util.HashMap ; public class T34_FirstNotRepeatingChar { public int FirstNotRepeatingCharHashMap ( String str ){ HashMap < Character , Integer > map = new HashMap <> (); if ( str == null ) return - 1 ; int length = str . length (); for ( int i = 0 ; i < length ; i ++ ) { if ( map . containsKey ( str . charAt ( i ))){ int value = map . get ( str . charAt ( i )); map . put ( str . charAt ( i ), value + 1 ); } else { map . put ( str . charAt ( i ), 1 ); } } for ( int i = 0 ; i < length ; i ++ ){ if ( map . get ( str . charAt ( i )) == 1 ) return i ; } return - 1 ; } } 图 （图的遍历 + 回溯法） 065-矩阵中的路径(BFS) √ 题目描述 : 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e 矩阵中包含一条字符串\"bcced\"的路径，但是矩阵中不包含\"abcb\"路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。 回溯法思路： 1. 从0 rows 0 cols 开始 坐标 (i,j) index依次加一判定 （ index = i * rows + j） 2. 需要一个flag数组记录 当前位置有没有被走过 public class Solution { public boolean hasPath ( char [] matrix , int rows , int cols , char [] str ) { boolean [] flags = new boolean [ matrix . length ]; // gone position is true int position = 0 ; for ( int i = 0 ; i < rows ; i ++){ for ( int j = 0 ; j < cols ; j ++){ if ( findPath ( matrix , rows , cols , i , j , position , str , flags )) return true ; } } return false ; } public boolean findPath ( char [] matrix , int rows , int cols , int i , int j , int position , char [] str , boolean [] flags ){ int curIndex = i * rows + j ; if ( i < 0 || i >= rows || j < 0 || j >= cols || matrix [ curIndex ] != str [ position ] || flags [ curIndex ]) return false ; if ( position == str . length - 1 ) return true ; flags [ curIndex ] = true ; // mark (i,j) as true if ( findPath ( matrix , rows , cols , i + 1 , j , position + 1 , str , flags )|| findPath ( matrix , rows , cols , i - 1 , j , position + 1 , str , flags )|| findPath ( matrix , rows , cols , i , j + 1 , position + 1 , str , flags )|| findPath ( matrix , rows , cols , i , j - 1 , position + 1 , str , flags )) return true ; // no possibility to find path at current index, so mark flags[curIndex] = false flags [ curIndex ] = false ; return false ; } } 066-机器人的运动范围(DFS) √ 题目描述: 地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？ 思路 1： 回溯 + 递归 1. 定义一个二维数组 flags 来标记走过的格子，这是之后递归函数退出的条件之一 2. 定义一个函数 sum 计算当前方格坐标阈值（行坐标和列坐标的数位之和），这也是之后递归函数退出的条件之一 3. 根据题意构造回溯方法，返回值为满足条件的格子数 4. 按照上下左右顺序，递归调用回溯方法，只要满足则count值+1 递归解题代码：（java） public class Solution { public int movingCount ( int threshold , int rows , int cols ) { int [][] flags = new int [ rows ][ cols ] ; return count ( 0 , 0 , threshold , rows , cols , flags ) ; } private int count ( int i , int j , int threshold , int rows , int cols , int [][] flags ) { if ( i < 0 || j < 0 || i >= rows || j >= cols || sum ( i , j ) > threshold || flags [ i ][ j ] == 1 ) return 0 ; flags [ i ][ j ] = 1 ; // 按照上下左右格子的顺序递归调用回溯方法 return count ( i - 1 , j , threshold , rows , cols , flags ) + count ( i + 1 , j , threshold , rows , cols , flags ) + count ( i , j - 1 , threshold , rows , cols , flags ) + count ( i , j + 1 , threshold , rows , cols , flags ) + 1 ;// 当前格子满足条件，返回值+1 } private int sum ( int i , int j ) { int sum = 0 ; do { sum += i % 10 ; i = i / 10 ; } while ( i > 0 ) ; do { sum += j % 10 ; j = j / 10 ; } while ( j > 0 ) ; return sum ; } } 思路 2： 回溯 + 非递归 1. 定义一个 flags 来标记走过的格子，这是之后递归函数退出的条件之一 2. 定义一个函数 sum 计算当前方格坐标阈值（行坐标和列坐标的数位之和），这也是之后递归函数退出的条件之一 3. 递归的本质是系统帮压栈，所以非递归实现则是自己定义一个栈 stack 用来记录还没有被访问过的上下左右邻居，如果满足条件则压入栈 4. 每次弹出一个栈顶元素，直到栈为空 非递归解题代码：（java） import java.util.Stack ; public class Solution { public int movingCount ( int threshold , int rows , int cols ) { if ( threshold < 0 || rows < 0 || cols < 0 ) return 0 ; // 上下左右格子 int [] x = { - 1 , 1 , 0 , 0 }; int [] y = { 0 , 0 , - 1 , 1 }; boolean [] flags = new boolean [ rows * cols ]; flags [ 0 ] = true ; // 访问过标记为 true Stack < Integer > stack = new Stack <> (); stack . add ( 0 ); int count = 0 ; while ( ! stack . isEmpty ()){ int curIndex = stack . pop (); count += 1 ; for ( int i = 0 ; i < 4 ; i ++ ){ int curRow = curIndex / cols + x [ i ]; int curCol = curIndex % cols + y [ i ]; int digitalSum = sum ( curRow , curCol ); if ( curCol >= 0 && curCol < cols && curRow >= 0 && curRow < rows && digitalSum <= threshold && ! flags [ curRow * cols + curCol ]){ stack . add ( curRow * cols + curCol ); flags [ curRow * cols + curCol ] = true ; } } } return count ; } private int sum ( int i , int j ){ int sum = 0 ; do { sum += i % 10 ; i = i / 10 ; } while ( i > 0 ); do { sum += j % 10 ; j = j / 10 ; } while ( j > 0 ); return sum ; } }","tags":"interview","url":"/20191006.html","loc":"/20191006.html"},{"title":"动态规划专项练习-20190928","text":"动态规划 目录： 动态规划 动态规划思考步骤： ​ 1 原问题： ​ ​ 2 子问题： ​ ​ 3 确认状态： ​ ​ 4 初始状态： ​ ​ 5 状态转移方程： ​ 例1: 爬楼梯 例2: 打家劫舍 例3:最大子段和 例4：找零钱 例5：三角形数组和最小路径 （二维DP） 例6 ： 最长上升子序列 例7： 二维矩阵中左上角到右下角的最短路径和 例8:地牢游戏 动态规划解题步骤 核心思想是 递推 ，难点在于想起出 状态 dp[i] 代表什么，然后构造状态转移矩阵，利用初始条件递推出最终结果 将原问题拆分成子问题 确认状态 确认边界状态（初始条件） 状态转移方程 例1: 爬楼梯 LeetCode 70. Climbing Stairs 四步走: 将原问题拆分成子问题 原问题：在爬楼梯时，每次可向上走1阶台阶或2阶台阶，问有n阶楼 梯有多少种上楼的方式？ 子问题：第三阶台阶有多少种方法？第四阶呢？ 确认状态 第 i 个状态 即为第 i 阶台阶的所有走法数量 确认边界状态（初始条件）： 边界状态为1阶台阶与2阶台阶的走法，1 阶台阶有1种走法，2阶台阶有2种走法， 即dp[1] = 1，dp[2] = 2。 状态转移方程 dp[i] = dp[i-1] + dp[i-2]; (i>=3) 解题代码： public int climbStairs ( int n ) { if ( n == 1 ){ return 1 ; } int [] dp = new int [ n + 1 ]; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; for ( int i = 3 ; i <= n ; i ++) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ]; return dp [ n ]; } 例2: 打家劫舍 动态规划思考步骤： 1 原问题： LeetCode 198. House Robber 在一条直线上，有n个房屋，每个房屋中有数量不等的财宝，有一个盗 贼希望从房屋中盗取财宝，由于房屋中有报警器，如果同时从相邻的两个房屋中盗取财宝就会触发报警器。问在不触发报警器的前提下，最多可获取多少财宝？例如 [5，2，6，3，1，7]，则选择5，6，7 2 子问题： 只考虑前两个房间时，谁大选谁 考虑第三个房间 如果偷第三个房间，则意味着第二个房间不投，也就是第三个房间值 + 第一个房间的宝藏数量 如果不偷第三个房间，则宝藏数量等于前两个房间宝藏数量 3 确认状态： int [] nums; // 各个房间的宝藏数 int [] flags = new int [n]; // 记录各个房间有没有被偷，若flag = 0 则没偷， flag = 1 则偷了。 int [] dp = new int [n]; // dp[i]表示前i个房间偷到的最大宝藏数 4 初始状态： 第一个房间： Condistion 1 ：dp[0] = nums[0] ; flags[0] = 1; Condistion 2 ：dp[0] = 0; flags[0] = 0; 第二个房间： Condistion 1 ：when flags[1] = 1; dp[1] = nums[1]; Condistion 2 ：whenflags[1] = 0; dp[1] = dp[0]; 选 Condistion 1 还是 Condistion 2呢？ 比较 两种情况下dp[1]的大小 推广到前i个房间: (i>=2) when flags[i] = 1, dp[i] = nums[i] + dp[i-2] when flags[i] = 0; dp[i] = dp[i-1] 5 状态转移方程： dp [ 0 ] = nums [ 0 ]; dp [ 1 ] = max ( nums [ 0 ], nums [ 1 ]); for ( int i = 2 ; i < n ; i ++) dp [ i ] = max ( nums [ i ] + dp [ i - 2 ], dp [ i - 1 ]) 解题代码 class Solution { public int rob ( int [] nums ) { if ( nums . length == 0 ) return 0 ; int [] dp = new int [ nums . length ]; dp [ 0 ] = nums [ 0 ]; // 每次做数组判定时都需要做数组边界判定，防止越界 if ( nums . length < 2 ) return nums [ 0 ]; dp [ 1 ] = ( nums [ 0 ]> nums [ 1 ]) ? nums [ 0 ] : nums [ 1 ]; for ( int i = 2 ; i < nums . length ; i ++) dp [ i ] = (( nums [ i ] + dp [ i - 2 ]) > dp [ i - 1 ]) ? ( nums [ i ]+ dp [ i - 2 ]) : dp [ i - 1 ]; return dp [ nums . length - 1 ]; } } 例3:最大子段和 动态规划思考步骤： 1 原问题 LeetCode 53. Maximum Subarray 给定一个数组，求这个数组的连续子数组中，最大的那一段的和。 如数组[-2,1,-3,4,-1,2,1,-5,4] 的子段为： [-2,1]、[1,-3,4,-1]、[4,-1,2,1]、...、[-2,1,-3,4,-1,2,1,-5,4]，和最大的是[4,1,2,1]，为6。 Input : int [] nums = [- 2 , 1 ,- 3 , 4 ,- 1 , 2 , 1 ,- 5 , 4 ], Output : 6 Explanation : [ 4 ,- 1 , 2 , 1 ] has the largest sum = 6 . 2 子问题 只考虑第一个元素，则最大子段和为其本身 DP[0] = nums[0] 考虑前两个元素，最大子段和为 nums[0],num[1]以及 nums[0] + num[1] 中最大值 设为DP[1] 考虑前三个元素，如何求其最大子段和？还是分为两种情况讨论，第三个元素在最后的字串内吗？ 若第三个元素也包含在最后的字串内，则DP[2] = Max(DP[1]+nums[2] , nums[2]) 3 确认状态 DP[i] 为 以nums[i]结尾的子段的最大最短和 例如 DP[1]则为以nums[1]结尾的最大字段和 4 初始状态 dp[0] = nums[0] dp[1] = max(dp[0]+nums[1] , nums[1]) 5 状态转移方程： dp[i] = max(dp[i-1]+nums[i],nums[i]) 解题代码： public class lc53_MaximumSubarray { public int maxSubArray ( int [] nums ) { int len = nums . length ; if ( len == 0 ) return 0 ; int [] dp = new int [ len ]; dp [ 0 ] = nums [ 0 ]; int max = dp [ 0 ]; for ( int i = 1 ; i < len ; i ++){ dp [ i ] = ( dp [ i - 1 ]+ nums [ i ] > nums [ i ]) ? dp [ i - 1 ]+ nums [ i ] : nums [ i ]; if ( dp [ i ]> max ) max = dp [ i ]; } return max ; } } 例4：找零钱 LeetCode 322. Coin Change 已知不同面值的钞票，求如 何用最少数量的钞票组成某个金额，求可 以使用的最少钞票数量。如果任意数量的已知面值钞票都无法组成该金额， 则返回-1。 Input : coins = [ 1 , 2 , 5 ], amount = 11 Output : 3 Explanation : 11 = 5 + 5 + 1 Input : coins = [ 2 ], amount = 3 Output : - 1 动态规划解题步骤： 将原问题拆分成子问题 已知什么？显而易见，钞票的金额都只需要其本身1张即可 如何在已知钞票的情况下构造出 金额X需要的最少钞票组合 确认状态 DP[0] - DP[amount] 表示构造金额amount需要的最小钞票数 确认边界状态（初始条件） DP[coin] = 1 其他的都未知初始值设为 -1 例如coins = [1, 2, 5], amount = 11 已知 dp[1]、dp[2]、dp[5] =1 现在已知 DP[coin] 需要求出每一个DP[amount] 状态转移方程 dp[i] = min(dp[i-1], dp[i-2], dp[i-5]) + 1 解题代码：（java） public int coinChange ( int [] coins , int amount ) { int len = coins . length ; if ( len == 0 || amount < 0 ) return - 1 ; if ( amount == 0 ) return 0 ; int [] dp = new int [ amount + 1 ]; for ( int i = 0 ; i <= amount ; i ++){ dp [ i ] = - 1 ; } for ( int i = 0 ; i < len ; i ++){ if ( coins [ i ] == amount ) return 1 ; if ( coins [ i ] < amount ) dp [ coins [ i ]] = 1 ; } // State Transfer Function for ( int i = 1 ; i <= amount ; i ++){ for ( int j = 0 ; j < len ; j ++){ if ( i - coins [ j ] >= 0 && dp [ i - coins [ j ]] != - 1 ){ if ( dp [ i ] == - 1 || dp [ i ] > dp [ i - coins [ j ]] + 1 ){ dp [ i ] = dp [ i - coins [ j ]] + 1 ; } } } } return dp [ amount ]; } 例5：三角形数组和最小路径 （二维DP） LeetCode 120. Triangle 动态规划解题步骤： 原问题： 给定一个二维数组，其保存了一个数字三角形 triangleMatrix[] []，求从数字三角形顶端到底端各数字和最小的路径之和，每次可以向下走相邻的两个位置 For example, given the following triangle [ [2], [3,4], [6,5,7], [4,1,8,3] ] The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11). 子问题： 到达每一个节点的最短路径和是多少？知道上一层每一个节点的最短路径和数组可以递推出下一层的最短路径和吗？ 确认状态 构造一个大小与三角形矩阵一致的最短路径和矩阵 DP[ ] [ ] ，DP[i] [j] 表示到达第i行 第j列节点的最短路径和 初始条件和边界条件 思考：从上往下走 和 从下往上走本质是一样的，怎么做实现起来会更方便呢？ 从下往上，最短路径矩阵底层所有元素值就等于三角形矩阵底层所有元素值，然后往上递推。 每一个节点的最短路径值只需要考虑它下一层正下方和右下方最短路径矩阵中哪个更小，与其相加即可 状态转移方程： 从下往上递推： DP[i] [j] = min(DP[i+1] [j], DP[i+1] [j+1]) + triangleMatrix [i] [j] 最终返回 DP[0] [0] 解题代码：（java） import java.util.ArrayList ; public class lc120_Triangle { public int minimumTotal ( ArrayList < ArrayList < Integer >> triangle ) { /* // method 1 - modify the original list for(int i = triangle.size() - 2; i >= 0; i--) for(int j = 0; j <= i; j++) triangle.get(i).set(j, triangle.get(i).get(j) + Math.min(triangle.get(i + 1).get(j), triangle.get(i + 1).get(j + 1))); return triangle.get(0).get(0); */ if ( triangle . isEmpty ()) return 0 ; if ( triangle . size () == 1 ) return triangle . get ( 0 ). get ( 0 ); int [][] dp = new int [ triangle . size ()][ triangle . get ( triangle . size ()- 1 ). size ()]; // Bottom level initialization for ( int i = 0 ; i < triangle . get ( triangle . size ()- 1 ). size (); i ++) dp [ triangle . size ()- 1 ][ i ] = triangle . get ( triangle . size ()- 1 ). get ( i ); // From the last second line to the top line for ( int i = triangle . size ()- 2 ; i >= 0 ; i --){ for ( int j = 0 ; j <= i ; j ++){ dp [ i ][ j ] = Math . min ( dp [ i + 1 ][ j ], dp [ i + 1 ][ j + 1 ]) + triangle . get ( i ). get ( j ); } } return dp [ 0 ][ 0 ]; } } 例6 ： 最长上升子序列 LeetCode 300. Longest Increasing Subsequence 动态规划解题步骤： 原问题： 已知一个未排序数组，求这个数组最长上升子序列的长度。 例如: [1, 3, 2, 3, 1, 4]， 其中有很多上升子序列，如[1, 3]、[1, 2, 3]、 [1, 2, 3, 4]等，其中最长的上升子序列长度为4。分别考虑O(n&#94;2)与O(n*logn)两种复杂度算法 子问题： 到底怎么构造DP数组能够表示最长上升子序列的长度？ 如果在nums[i] 前面按顺序比nums[i]小的数字有N个，则DP[i] = N+1 （1为其本身） 例如 nums[1] = 3， 往前找，有1个按递减顺序比我小的数字，则DP[1] = 1+1 = 2 例如 nums[5] = 4， 往前找，有3个依次递减的数字 【3,2,1】，则DP[5] = 3+1 = 4 为了递推可以进行下去，比nums[i]小这个条件可以忽略，先找到前面最长的上升序列，然后找到有几个比当前节点nums[i]小的 所以问题变成了维持一个到当前节点为止(包含当前节点)，最长的上升序列，然后与当前节点做比较，求得DP[i] 再往深想一步，如何维持这个最长上升序列呢？ 只保留其长度len 和其中最大值max[i]是否就可以？ 此时，DP[i] = Max(（if nums[i]>max[j]）DP[j] + 1 ) 最终搞清楚了确认状态： DP[i]是以nums[i]结尾的最长上升子序列长度 状态转移函数也很好理解：DP[i] = j 从 0 到 i-1，只要nums[j] < nums[i] 且 DP[i] < DP[j] + 1, DP[i] = DP[j] + 1 确认状态： DP[i] 表示到nums[i]为止最长上升序列的长度 从i=0开始往后递推，维持一个最长上升序列 increasingList [] 最终搞清楚了确认状态： DP[i]是以nums[i]结尾的最长上升子序列长度 初始条件和边界条件： DP[0] = 1 最大上升字串长度LIS = 1 状态转移方程： DP[i] = j 从 0 到 i-1，只要nums[j] < nums[i] 且 DP[i] < DP[j] + 1, DP[i] = DP[j] + 1 只要 DP[i] > LIS, LIS = DP[i] 解题代码 1：（java） class Solution { // solution 1 : time complexity = O(n&#94;2) public int lengthOfLIS ( int [] nums ) { int len = nums . length ; if ( len == 0 ) return 0 ; // when index = i, the length of longest increasing subsequence int [] dp = new int [ len ]; dp [ 0 ] = 1 ; int max = dp [ 0 ]; for ( int i = 0 ; i < len ; i ++){ dp [ i ] = 1 ; for ( int j = 0 ; j < i ; j ++){ // State Transition Function if ( nums [ i ] > nums [ j ] && dp [ i ] < dp [ j ]+ 1 ) dp [ i ] = dp [ j ]+ 1 ; } if ( dp [ i ]> max ) max = dp [ i ]; } return max ; } } 例7： 二维矩阵中左上角到右下角的最短路径和 LeetCode 64. Minimum Path Sum Input : [ [ 1 , 3 , 1 ], [ 1 , 5 , 1 ], [ 4 , 2 , 1 ] ] Output : 7 Explanation : Because the path 1 → 3 → 1 → 1 → 1 minimizes the sum . 动态规划解题步骤： 原问题： 已知一个二维数组，其中存储了非负整数，找到从左上角到右下角的一 条路径，使得路径上的和最小。(移动过程中只能向下或向右) 子问题 到达每一个节点的最小路径值是不是可以依次递推求出来？ 确定状态和初始状态 状态为一个和输入矩阵一样大的DP矩阵，其中DP[i] [j]存到达节点[i] [j]的最短路径和,初始值设为-1表明没有遍历到 初始状态知道DP[0] [0] DP[0] [1] 和 DP[1] [0] 状态转移方程 DP[i] [j] = min(DP[i-1] [j] , DP[i] [j-1]) + input[i] [j] 解题代码：（java） public class lc64_MinimumPathSum { public int minPathSum ( int [][] grid ) { if ( grid == null || grid . length == 0 ) return 0 ; int row = grid . length ; int col = grid [ 0 ]. length ; int [][] dp = grid ; // state transaction function for ( int i = 0 ; i < row ; i ++) { for ( int j = 0 ; j < col ; j ++) { // initialization // Do not forget continue! if ( i == 0 && j == 0 ) { dp [ i ][ j ] = grid [ 0 ][ 0 ]; continue ; } if ( i == 0 ){ dp [ i ][ j ] = dp [ i ][ j - 1 ] + grid [ i ][ j ]; continue ; } if ( j == 0 ){ dp [ i ][ j ] = dp [ i - 1 ][ j ] + grid [ i ][ j ]; continue ; } // normal dp [ i ][ j ] = Math . min ( dp [ i ][ j - 1 ], dp [ i - 1 ][ j ]) + grid [ i ][ j ]; System . out . println ( \"i = \" + i + \" j = \" + j + \" DP = \" + dp [ i ][ j ]); } } return dp [ row - 1 ][ col - 1 ]; } } 例8:地牢游戏 LeetCode 174. Dungeon Game 动态规划解题步骤： 原问题： 已知一个二维数组，左上角代表骑士的位置，右下角代表公主的位置， 二维数组中存储整数，正数可以给骑士增加生命值，负数会减少骑士的生命值，问骑士初始时至少是多少生命值，才可保证骑士在行走的过程中至少保持生命值为1。(骑士只能向下或向右行走) 子问题： 本题初看和例题6有点类似，而且最小初始血量也很好定义出来，为 1 - 当前血量 又因为要求最小血量为1，所以当前节点的最小血量应该为 max（1， 1 - 当前血量） 从左上往右下推初始血量很困难，但是从右下往左上可以轻松倒推出当前血量至少为多少才可以保证到达重点时血量不低于1。 确认状态 + 初始状态 DP[i] [j] 表示保证到达终点时血量不低于1的最小血量，最小值取 1 保证不在中途阵亡 这就意味着 DP[0] [0] 就是我们要求的最小初始血量 状态转移方程 从右下开始往左上走，每次只能向上或者向左 minHP = min(dp[i+1] [j] , dp[i] [j+1]) // 右边的 或者下边的最小血量 DP [i] [j] = max(1, 1 - minHP) // 1- minHP 是为了让自己活下来最小血量，1为最小值 解题代码：（java） public class lc174_DungeonGame { public int calculateMinimumHP ( int [][] dungeon ) { if ( dungeon == null || dungeon . length == 0 ) return 0 ; int row = dungeon . length ; int col = dungeon [ 0 ]. length ; int [][] dp = dungeon ; int dp_min = 0 ; // state transaction function for ( int i = row - 1 ; i >= 0 ; i --) { for ( int j = col - 1 ; j >= 0 ; j --) { // initialization // Do not forget continue! if ( i == row - 1 && j == col - 1 ) { dp [ i ][ j ] = Math . max ( 1 , 1 - dungeon [ i ][ j ]); continue ; } if ( i == row - 1 ){ dp [ i ][ j ] = Math . max ( 1 , dp [ i ][ j + 1 ]- dungeon [ i ][ j ]); continue ; } if ( j == col - 1 ){ dp [ i ][ j ] = Math . max ( 1 , dp [ i + 1 ][ j ]- dungeon [ i ][ j ]); continue ; } // normal dp_min = Math . min ( dp [ i ][ j + 1 ], dp [ i + 1 ][ j ]); dp [ i ][ j ] = Math . max ( 1 , dp_min - dungeon [ i ][ j ]); } } return dp [ 0 ][ 0 ]; } } 动态规划总结： 这篇文章从28号晚上陆陆续续一直写到30号晚上，主要是基于小象学院 《面试算法LeetCode刷题班》中动态规划的一章，今天去官网看发现课程已经下架了，故将课程课件放在了我GitHub秋招面试准备 repo 中，有需要的朋友可以自己下载。 动态规划是很大一类算法题，也是各大互联网公司笔试面试中逃不掉的一个测试算法基本功的题型。本文只做了一个入门，动态规划系列文章随着我学习的深入，会陆续发布在专栏中。 愿诸君阅读愉快，学习进步。","tags":"interview","url":"/20190928-DP.html","loc":"/20190928-DP.html"},{"title":"剑指offer|解题代码-2-Tree","text":"目录： Tree ​ 004-重建二叉树 √ ​ 017-树的子结构 √ ​ 018-二叉树的镜像 √ ​ 022-从上往下打印二叉树 （二叉树按层遍历）√ ​ 023-二叉搜索树的后序遍历序列 √ ​ 024-二叉树中和为某一值的路径 √ ​ 026-二叉搜索树与双向链表 √ ​ 038-二叉树的深度 √ ​ 039-平衡二叉树 √ ​ 057-二叉树的下一个结点 √ ​ 058-对称的二叉树 √ ​ 059-按之字形顺序打印二叉树 √ ​ 060-把二叉树打印成多行 （层序遍历，逐层打印） √ ​ 061-序列化二叉树 √ ​ 062-二叉搜索树的第k个结点 √ Tree 004-重建二叉树 √ 2019-3-6 13:09 --- 2019-3-6 13:24 题目描述：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 分析： 1. 前序遍历的第一个元素为树的根节点 root， 后面n个左子树元素，m个右子树元素 2. 中序遍历中 root结点的左边元素为所有左子树元素共n个， 右边元素为所有右子树元素共m个 思路：递归方法 1. 前序遍历第一个元素为 root 2. 中序遍历找到root的index， [:index]为左子树的中序遍历， [index+1:]为右子树中序遍历 3. 前序遍历中 [1:index+1]为左子树的前序遍历，[index+1:]为右子树的前序遍历 4. 递归 传入左子树和右子树的前序/中序遍历 5. 递归终止条件： 前序/中序遍历为空 return None 解题代码：（java） /** * Definition for binary tree * public class TreeNode { * int val ; * TreeNode left ; * TreeNode right ; * TreeNode ( int x ) { val = x ; } * } */ import java.util.Arrays ; public class Solution { public TreeNode reConstructBinaryTree ( int [] pre , int [] in ) { if ( pre . length == 0 || in . length == 0 ) return null ; TreeNode root = new TreeNode ( pre [ 0 ]); int index = 0 ; for ( int i = 0 ; i < in . length ; i ++ ){ if ( pre [ 0 ] == in [ i ]){ index = i ; break ; } } int [] leftPre = Arrays . copyOfRange ( pre , 1 , index + 1 ); int [] leftIn = Arrays . copyOfRange ( in , 0 , index ); int [] rightPre = Arrays . copyOfRange ( pre , index + 1 , pre . length ); int [] rightIn = Arrays . copyOfRange ( in , index + 1 , in . length ); root . left = reConstructBinaryTree ( leftPre , leftIn ); root . right = reConstructBinaryTree ( rightPre , rightIn ); return root ; } } 解题代码：（Python） # -*- coding:utf-8 -*- # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution : # 返回构造的TreeNode根节点 def reConstructBinaryTree ( self , pre , tin ): if not pre or not tin : return None root = TreeNode ( pre [ 0 ]) index = tin . index ( pre [ 0 ]) root . left = self . reConstructBinaryTree ( pre [ 1 : index + 1 ], tin [: index ]) root . right = self . reConstructBinaryTree ( pre [ index + 1 :], tin [ index + 1 :]) return root 017-树的子结构 √ 题目描述 : 输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） 思路： 遍历树A，找到值与树B root值相同的结点 执行判断函数，检查左右孩子结点是否相同 解题代码：（Java） /** public class TreeNode { int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) { this.val = val; } } */ public class Solution { public boolean HasSubtree ( TreeNode root1 , TreeNode root2 ) { boolean result = false ; if ( root1 != null && root2 != null ){ if ( root1 . val == root2 . val ) result = isTree1HasTree2 ( root1 , root2 ); if ( result != true ) result = HasSubtree ( root1 . left , root2 ); if ( result != true ) result = HasSubtree ( root1 . right , root2 ); } return result ; } public boolean isTree1HasTree2 ( TreeNode root1 , TreeNode root2 ){ if ( root2 == null ) return true ; if ( root1 == null ) return false ; if ( root1 . val != root2 . val ) return false ; return isTree1HasTree2 ( root1 . left , root2 . left ) && isTree1HasTree2 ( root1 . right , root2 . right ); } } 018-二叉树的镜像 √ 题目描述 : 操作给定的二叉树，将其变换为源二叉树的镜像。 思路： 递归遍历二叉树，交换每一个节点的左右孩子 解题代码：（Java） public class Solution { public void Mirror ( TreeNode root ) { if ( root != null ){ // swap left and right child TreeNode temNode = root . left ; root . left = root . right ; root . right = temNode ; if ( root . left != null ) Mirror ( root . left ); if ( root . right != null ) Mirror ( root . right ); } } } 022-从上往下打印二叉树 （二叉树按层遍历）√ 题目描述 : 从上往下打印出二叉树的每个节点，同层节点从左至右打印。 思路： 1. Queue 将 root,root.left,root.right 依次加入Queue 补充知识： Java 集合 - LinkedList vs Queue 1. import java.util.LinkedList; 2. LinkedList queue = new LinkedList (); 3. queue.isEmpty(); // 判断是否为空 3. queue.offer();//将节点入队 （Push） 4. queue.poll();//队头元素出队并返回 (Pop) 解题代码：（Java） import java.util.ArrayList ; import java.util.LinkedList ; import java.util.Queue ; /** public class TreeNode { int val = 0 ; TreeNode left = null ; TreeNode right = null ; public TreeNode ( int val ) { this . val = val ; } } */ public class Solution { public ArrayList < Integer > PrintFromTopToBottom ( TreeNode root ) { ArrayList < Integer > resList = new ArrayList < Integer > (); Queue < TreeNode > queue = new LinkedList < TreeNode > (); // debug ： new LinkedList < TreeNode > () <> 后的括号 () 漏了！注意细节。 if ( root == null ) return resList ; TreeNode curNode = null ; queue . offer ( root ); while ( ! queue . isEmpty ()){ curNode = queue . poll (); if ( curNode . left != null ){ queue . offer ( curNode . left ); } if ( curNode . right != null ){ queue . offer ( curNode . right ); } resList . add ( curNode . val ); } return resList ; } } 023-二叉搜索树的后序遍历序列 √ 题目描述 : 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。 补充知识 1 ： 二叉搜索树(Binary Search Tree) or 排序二叉树（Sorted Binary Tree） 1. 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值； 2. 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值； 3. 任意节点的左、右子树也分别为二叉查找树； 4. 没有键值相等的节点。 补充知识 2 ： 树的前中后序遍历，前中后是指根节点root被打印的顺序，后序意味着打印顺序为 左右根 例如： [5，7，6] 可以是 BST 5-6-7 的后序遍历，故返回Ture，然而并没有一棵BST的后序遍历能够为 [7,4,6,5] 分析后可以得知，BST 后序遍历的序列有如下特征： 1. 最后一个节点为 root 2. [0] - [len-2] 被分成两段，前一段为root的左孩子节点，值都小于root.val， 后一段为root 的右孩子节点，值都大于root.val 3. 根据 BST 的特性，对左右孩子进行递归调用继续判断 解题代码：（Java） // 问题主要在于：一直在 copy 数组，效率较低 import java.util.Arrays ; public class Solution { public boolean VerifySquenceOfBST ( int [] sequence ) { int len = sequence . length ; if ( len <= 0 || sequence == null ) return false ; int rootVal = sequence [ len - 1 ]; int i = 0 ; for (; i < len - 1 ; i ++ ){ if ( sequence [ i ] > rootVal ){ break ; } } int index = i ; for ( int j = i ; j < len - 1 ; j ++ ){ if ( sequence [ j ] < rootVal ) return false ; } boolean left = true ; boolean right = true ; if ( index > 0 ){ int [] leftNodes = Arrays . copyOfRange ( sequence , 0 , index ); left = VerifySquenceOfBST ( leftNodes ); } if ( index < len - 1 ){ int [] rightNodes = Arrays . copyOfRange ( sequence , index , len - 1 ); right = VerifySquenceOfBST ( rightNodes ); } return ( left && right ); } } 024-二叉树中和为某一值的路径 √ 20190924 总结： 这题前前后后刷了差不多2个小时 题目描述 : 输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前) 思路： 1. 每次都从根节点出发，需要一个栈结构记录路径 path，方便回溯，一个 int currentVal 记录当前路径节点值之和 2. 当 currentVal == targetVal 且 currentNode 是叶子节点时，输出路径path （逆序） 3. 当有孩子节点时递归调用 FindPath方法 4. 注意： 如果当前节点为叶子节点但 currentVal ！= targetVal 则需要把 currentVal - currentNode.val 且 从路径中删除当前节点，然后返回父节点 import java.util.ArrayList ; import java.util.Stack ; /** public class TreeNode { int val = 0 ; TreeNode left = null ; TreeNode right = null ; public TreeNode ( int val ) { this . val = val ; } } */ public class Solution { static ArrayList < ArrayList < Integer >> res = new ArrayList <> (); public ArrayList < ArrayList < Integer >> FindPath ( TreeNode root , int target ) { if ( root == null ) return null ; Stack < Integer > path = new Stack (); int currentVal = 0 ; FindPath ( root , target , path , currentVal ); System . out . println ( res ); return res ; } public void FindPath ( TreeNode root , int target , Stack < Integer > path , int currentVal ){ path . push ( root . val ); currentVal += root . val ; boolean isLeaf = ( root . left == null && root . right == null ); if ( currentVal == target && isLeaf ){ ArrayList < Integer > oneRes = new ArrayList <> (); while ( ! path . isEmpty ()){ oneRes . add ( 0 , path . pop ()); } res . add ( oneRes ); } // if no new path 2 , leftNodes will influence rightNodes Stack < Integer > path2 = new Stack (); path2 . addAll ( path ); if ( root . left != null ) FindPath ( root . left , target , path , currentVal ); if ( root . right != null ) FindPath ( root . right , target , path2 , currentVal ); // if can not find the path , delete the current node from the path and add if ( ! path . isEmpty ()) path . pop (); currentVal -= root . val ; } } 解题代码2（Java） public class Solution { public ArrayList < ArrayList < Integer >> FindPath ( TreeNode root , int target ) { ArrayList < ArrayList < Integer >> paths = new ArrayList < ArrayList < Integer >> () ; if ( root == null ) return paths ; find ( paths , new ArrayList < Integer > () , root , target ) ; return paths ; } public void find ( ArrayList < ArrayList < Integer >> paths , ArrayList < Integer > path , TreeNode root , int target ) { path . add ( root . val ) ; if ( root . left == null && root . right == null ) { if ( target == root . val ) { paths . add ( path ) ; } return ; } ArrayList < Integer > path2 = new ArrayList <> () ; path2 . addAll ( path ) ; if ( root . left != null ) find ( paths , path , root . left , target - root . val ) ; if ( root . right != null ) find ( paths , path2 , root . right , target - root . val ) ; } } 026-二叉搜索树与双向链表 √ 题目描述 : 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 思路： 1. 记录链表末尾节点 tail 2. 中序遍历，连接 tail 和 pRoot 3. 建议画图理解 else 内的3行连接代码 解题代码：（Java） /** public class TreeNode { int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) { this.val = val; } } */ public class Solution { TreeNode root = null ; // real root as return value TreeNode tail = null ; // the last node of LinkedList public TreeNode Convert ( TreeNode pRootOfTree ) { if ( pRootOfTree == null ) return null ; if ( pRootOfTree . left != null ) Convert ( pRootOfTree . left ) ; if ( root == null ) { root = pRootOfTree ; tail = pRootOfTree ; } else { // Link tail . right = pRootOfTree ; pRootOfTree . left = tail ; tail = pRootOfTree ; } if ( pRootOfTree . right != null ) Convert ( pRootOfTree . right ) ; return root ; } } 038-二叉树的深度 √ 题目描述 : 输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 解题代码：（Java） public class Solution { public int TreeDepth ( TreeNode root ) { if ( root == null ) return 0 ; int left = TreeDepth ( root . left ) ; int right = TreeDepth ( root . right ) ; return Math . max ( left , right ) + 1 ; } } 039-平衡二叉树 √ 题目描述 : 输入一棵二叉树，判断该二叉树是否是平衡二叉树。 补充知识： 平衡二叉树 平衡二叉树是一棵 空树 或它的 左右两个子树的高度差的绝对值不超过1 ，并且左右两个子树都是一棵平衡二叉树 思路： 非常直白，只需要计算左右子树高度，并且判断高度差是否小于等于1 解题代码 1：（Java） public class Solution { public boolean IsBalanced_Solution ( TreeNode root ) { return getDepth ( root ) != - 1 ; } public int getDepth ( TreeNode root ) { if ( root == null ) return 0 ; int left = getDepth ( root . left ) ; if ( left == - 1 ) return - 1 ; int right = getDepth ( root . right ) ; if ( right == - 1 ) return - 1 ; return Math . abs ( left - right ) > 1 ? - 1 : Math . max ( left , right ) + 1 ; } } 解题代码 2： (java) import java.lang.Math ; public class Solution { public boolean IsBalanced_Solution ( TreeNode root ) { if ( root == null ) return true ; int left = getDepth ( root . left ); int right = getDepth ( root . right ); return Math . abs ( left - right ) <= 1 ; } public int getDepth ( TreeNode root ) { if ( root == null ) return 0 ; int left = getDepth ( root . left ); int right = getDepth ( root . right ); return Math . max ( left , right ) + 1 ; } } 057-二叉树的下一个结点 ** √ 题目描述 : 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 思路： 1. 有右孩子，则为右子树的最左节点 2. ==无右孩子，则找父节点，直到当前节点为其父节点的左孩子时，返回父节点== 解题代码：（Java） /* public class TreeLinkNode { int val; TreeLinkNode left = null; TreeLinkNode right = null; TreeLinkNode next = null; TreeLinkNode(int val) { this.val = val; } } */ public class Solution { public TreeLinkNode GetNext ( TreeLinkNode pNode ) { if ( pNode == null ) return pNode ; // 有右孩子，则为右子树的最左节点 if ( pNode . right != null ) return getLeftMost ( pNode . right ) ; // 无右孩子，则找父节点，直到当前节点为其父节点的左孩子时，返回父节点 else { TreeLinkNode parent = pNode . next ; while ( parent != null && parent . left != pNode ) { pNode = parent ; parent = pNode . next ; } return parent ; } } public TreeLinkNode getLeftMost ( TreeLinkNode node ) { if ( node == null ) return node ; while ( node . left != null ) { node = node . left ; } return node ; } } 058-对称的二叉树 √ 题目描述 : 请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。 思路： 判断左子树和右子树对称 解题代码：（Java） public class Solution { boolean isSymmetrical ( TreeNode pRoot ) { if ( pRoot == null ) return true ; return isSymmetrical ( pRoot . left , pRoot . right ); } boolean isSymmetrical ( TreeNode r1 , TreeNode r2 ){ if ( r1 == null && r2 == null ) return true ; if ( r1 != null && r2 != null ) return r1 . val == r2 . val && isSymmetrical ( r1 . left , r2 . right ) && isSymmetrical ( r1 . right , r2 . left ); return false ; } } 059-按之字形顺序打印二叉树 √ 思路： 1. 层序遍历的思想 （队列） 2. 左右打印顺序用一个boolean flag来控制 基于层序遍历按层输出的代码，加入reverse，并不需要两个stack 核心： 1. preLayerLastNode 记录上一层最后的节点 2. curLayerLastNode 记录当前层最后的节点 （当前层意味着正在将孩子节点加入队列，本题用linkedList实现） 解题代码：（Java） public class Solution { public ArrayList < ArrayList < Integer >> Print ( TreeNode root ) { ArrayList < ArrayList < Integer >> resLists = new ArrayList < ArrayList < Integer >>(); if ( root == null ) return resLists ; ArrayList < Integer > resList = new ArrayList < Integer >(); LinkedList < TreeNode > queue = new LinkedList < TreeNode >(); TreeNode preLayerLastNode = root ; // pre layer last node TreeNode curLayerLastNode = root ; // current layer last node boolean leftToRight = true ; // Flag using to control print order queue . offer ( root ); while (! queue . isEmpty ()){ TreeNode curNode = queue . poll (); if ( curNode . left != null ){ queue . offer ( curNode . left ); curLayerLastNode = queue . getLast (); } if ( curNode . right != null ){ queue . offer ( curNode . right ); curLayerLastNode = queue . getLast (); } if ( curNode == preLayerLastNode ){ // add // add resList to resLists and create a new resList resList . add ( curNode . val ); if ( leftToRight ) resLists . add ( resList ); else { Collections . reverse ( resList ); resLists . add ( resList ); } preLayerLastNode = curLayerLastNode ; resList = new ArrayList < Integer >(); leftToRight = ! leftToRight ; } else { resList . add ( curNode . val ); } } return resLists ; } } 060-把二叉树打印成多行 （层序遍历，逐层打印） √ 题目描述 : 从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。 思路：层序遍历 + 层最后节点判定 参考： 二叉树逐层遍历打印 解题代码：（java） import java.util.ArrayList ; import java.util.LinkedList ; /* public class TreeNode { int val = 0 ; TreeNode left = null ; TreeNode right = null ; public TreeNode ( int val ) { this . val = val ; } } */ public class Solution { ArrayList < ArrayList < Integer > > Print ( TreeNode root ) { ArrayList < ArrayList < Integer >> resLists = new ArrayList < ArrayList < Integer >> (); if ( root == null ) return resLists ; ArrayList < Integer > resList = new ArrayList < Integer > (); LinkedList < TreeNode > queue = new LinkedList < TreeNode > (); TreeNode preLayerLastNode = root ; // pre layer last node TreeNode curLayerLastNode = root ; // current layer last node queue . offer ( root ); while ( ! queue . isEmpty ()){ TreeNode curNode = queue . poll (); if ( curNode . left != null ){ queue . offer ( curNode . left ); curLayerLastNode = queue . getLast (); } if ( curNode . right != null ){ queue . offer ( curNode . right ); curLayerLastNode = queue . getLast (); } if ( curNode == preLayerLastNode ){ // add resList to resLists and create a new resList resList . add ( curNode . val ); resLists . add ( resList ); preLayerLastNode = curLayerLastNode ; resList = new ArrayList < Integer > (); } else { resList . add ( curNode . val ); } } return resLists ; } } 061-序列化二叉树 √ 题目描述 : 请实现两个函数，分别用来序列化和反序列化二叉树 二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。 二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。 思路： 1. 序列化是前序遍历的变形，加入到一个String中 2. 反序列化也是前序遍历的变形，利用一个LinkedList or Queue结构存储node vals 构造Tree 解题代码：（java） import java.util.LinkedList ; import java.util.Queue ; public class Solution { String Serialize ( TreeNode root ) { if ( root == null ){ return \"#!\" ; } String res = root . val + \"!\" ; res += Serialize ( root . left ); res += Serialize ( root . right ); return res ; } TreeNode Deserialize ( String str ) { String [] nodes = str . split ( \"!\" ); Queue < String > queue = new LinkedList < String > (); for ( int i = 0 ; i < nodes . length ; i ++ ){ queue . offer ( nodes [ i ]); } return DeserialTreeByPreOrder ( queue ); } TreeNode DeserialTreeByPreOrder ( Queue < String > queue ) { String node = queue . poll (); if ( node . equals ( \"#\" )) return null ; TreeNode head = new TreeNode ( Integer . valueOf ( node )); head . left = DeserialTreeByPreOrder ( queue ); head . right = DeserialTreeByPreOrder ( queue ); return head ; } } 062-二叉搜索树的第k个结点 √ 题目描述: 给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）中，按结点数值大小顺序第三小结点的值为4。 解题代码： public class Solution { int n = 0 ; TreeNode res = null ; TreeNode KthNode ( TreeNode pRoot , int k ) { if ( pRoot == null ) return null ; KthNode ( pRoot . left , k ) ; n += 1 ; if ( n == k ) res = pRoot ; KthNode ( pRoot . left , k ) ; return res ; } } 解题代码2：（Java） public class Solution { int n = 0 ; TreeNode res = null ; TreeNode KthNode ( TreeNode pRoot , int k ) { if ( pRoot == null ) return null ; if ( pRoot . left != null ){ KthNode ( pRoot . left , k ); } n ++; if ( n == k ){ res = pRoot ; } if ( pRoot . right != null ){ KthNode ( pRoot . right , k ); } return res ; } }","tags":"interview","url":"/20190926-Tree.html","loc":"/20190926-Tree.html"},{"title":"剑指offer|解题代码-1-LinkedList","text":"目录： LinkedList ​ 003-从尾到头打印链表 √ ​ 014-链表中倒数第k个结点 √ ​ 015-反转链表 √ ​ 016-合并两个或k个有序链表 √ ​ 025-复杂链表的复制 ​ 036-两个链表的第一个公共结点 √ ​ 055-链表中环的入口结点 √ ​ 056-删除链表中重复的结点 √ LinkedList 003-从尾到头打印链表 √ 题目描述: 输入一个链表，按链表从尾到头的顺序返回一个ArrayList。 思路：所以逆序的操作都应该想到 stack 这个先进后出的数据结构 建立一个辅助栈 stack 和一个存储结构 ArrayList 将 原来链表中的值 一个个 push到 stack中 将 stack中存储的值 一个个 pop 到 ArrayList 解题代码：（Java） /** * Q : 输入一个链表，按链表从尾到头的顺序返回一个 ArrayList 。 * public class ListNode { * int val ; * ListNode next = null ; * * ListNode ( int val ) { * this . val = val ; * } * } * */ import java.util.ArrayList ; import java.util.Stack ; public class Solution { public ArrayList < Integer > printListFromTailToHead ( ListNode listNode ) { // 0. special case [] if ( listNode == null ){ ArrayList list = new ArrayList (); return list ; } // 1. Create assistant Stack and new ListNode for store data Stack < Integer > temp = new Stack <> (); ArrayList < Integer > newList = new ArrayList <> (); ListNode t = listNode ; // 2. push to Stack in order while ( t != null ){ temp . push ( t . val ); t = t . next ; } // 3. pop to new list in order which reversed order while ( ! temp . isEmpty ()){ // check whether stack is empty ? ---> . isEmpty () newList . add ( temp . pop ()); } return newList ; } } 014-链表中倒数第k个结点 √ 题目描述: 输入一个链表，输出该链表中倒数第k个结点。 思路： 快慢指针 1. 定义两个指针 P1 P2 2. P1 先向后寻址 k-1 次 3. P1 P2同时向后寻址，当P1 == NULL 时，P2所指向的恰好为倒数第k个结点 解题代码：（Java） /* public class ListNode { int val; ListNode next = null; ListNode(int val) { this.val = val; } }*/ /* 思路： 定义两个指针 P1 P2 P1 先向后寻址 k-1 次 然后P1 P2同时向后寻址，当P1 == NULL 时，P2所指向的恰好为倒数第k个结点 */ public class Solution { public ListNode FindKthToTail ( ListNode head , int k ) { if ( head == null || k <= 0 ) return null ; ListNode P1 = head ; ListNode P2 = head ; for ( int i = 0 ; i < k - 1 ; i ++){ if ( P1 . next != null ) P1 = P1 . next ; else return null ; } while ( P1 . next != null ){ P1 = P1 . next ; P2 = P2 . next ; } return P2 ; } } 015-反转链表 √ Q：输入一个链表，反转链表后，输出新链表的表头。 思路： 1. 找到反转后链表的 headNode 当cur.next == null 时， headNode = cur 2. 保证反转链表不出现断裂， 保存好 cur.next 结点 解题代码：（Java） */ public class Solution { public ListNode ReverseList ( ListNode head ) { ListNode pReversedHead = null ; ListNode pCur = head ; ListNode pPrev = null ; while ( pCur != null ){ ListNode pNext = pCur . next ; if ( pNext == null ) pReversedHead = pCur ; pCur . next = pPrev ; // 反向链表 的 Next 是之前的上一个结点 prev pPrev = pCur ; // 反向链表现在的节点 是之后的 prev节点 pCur = pNext ; } return pReversedHead ; } } 016-合并两个或k个有序链表 √ 题目描述: 输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 思路： 解题代码：（Java） 递归版本 /* public class ListNode { int val; ListNode next = null; ListNode(int val) { this.val = val; } }*/ public class Solution { // 递归版本 public ListNode Merge ( ListNode list1 , ListNode list2 ) { if ( list1 == null ) return list2 ; if ( list2 == null ) return list1 ; if ( list1 . val <= list2 . val ){ list1 . next = Merge ( list1 . next , list2 ); return list1 ; } else { list2 . next = Merge ( list1 , list2 . next ); return list2 ; } } } 非递归版本 /* public class ListNode { int val; ListNode next = null; ListNode(int val) { this.val = val; } }*/ public class Solution { // 非递归版本 public ListNode Merge ( ListNode list1 , ListNode list2 ) { if ( list1 == null ) return list2 ; if ( list2 == null ) return list1 ; ListNode list3 = new ListNode (- 1 ); ListNode head3 = list3 ; while ( list1 != null && list2 != null ){ if ( list1 . val <= list2 . val ){ list3 . val = list1 . val ; list1 = list1 . next ; } else { list3 . val = list2 . val ; list2 = list2 . next ; } list3 = list3 . next ; } while ( list1 != null ){ list3 . val = list1 . val ; list1 = list1 . next ; list3 = list3 . next ; } while ( list2 != null ){ list3 . val = list2 . val ; list2 = list2 . next ; list3 = list3 . next ; } return head3 ; // 报错 java.lang.NullPointerException } } 025-复杂链表的复制 题目描述: 输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空） 思路： 时间和空间效率最高的解法是复制+拆分 1. 复制原节点A后的A'放在A节点后 2. 遍历原节点A的random节点B，并将复制节点A'的random节点连接节点B' 3. 将链表拆分成 A->B>C 与 A'->B'->C' 解题代码：（Java） /* public class RandomListNode { int label; RandomListNode next = null; RandomListNode random = null; RandomListNode(int label) { this.label = label; } } */ /* public class Solution { public RandomListNode Clone(RandomListNode pHead) { // 0. 空链表情况 if (pHead == null){ return null; } // 1. 复制原节点A后的A'放在A节点后 RandomListNode cur = pHead; while(cur !=null){ RandomListNode repeat = new RandomListNode(cur.label); repeat.next = cur.next; cur.next = repeat; cur = cur.next; } //2. 遍历原节点A的random节点B，并将复制节点A'的random节点连接节点B' cur = pHead; while(cur != null){ cur.next.random = cur.random.next; // 自己画个图比较好理解 cur = cur.next.next; } // 3. 将链表拆分成 A->B>C 与 A'->B'->C' cur = pHead; // A RandomListNode newHead = pHead.next; // A' //RandomListNode newCur = newHead;//A' while(cur !=null){ RandomListNode cloneNode = cur.next;//A' cur.next = cur.next.next; // A -> B cloneNode.next = cloneNode.next.next;// A'->B' cur = cur.next;// A ---> B } return newHead; } } 036-两个链表的第一个公共结点 √ 题目描述: 输入两个链表，找出它们的第一个公共结点。 Date: 20190918 思路： 首先，存在公共结点的两个链表是Y字形的，而不可能出现X形的，意味着从第一个公共结点开始，它们的后续结点都相同。 1. 计算两个List的长度，得到长度查Dif 2. 长的List 先遍历 Dif次后，与短的List依次比较结点 3. 当结点相同，则为第一个公共结点 解题代码：（Java） /* public class ListNode { int val; ListNode next = null; ListNode(int val) { this.val = val; } }*/ public class Solution { public ListNode FindFirstCommonNode ( ListNode pHead1 , ListNode pHead2 ) { if ( pHead1 == null || pHead2 == null ){ return null ; } ListNode cur1 = pHead1 ; ListNode cur2 = pHead2 ; int pHead1Length = 0 ; int pHead2Length = 0 ; while ( cur1 != null ){ pHead1Length ++; cur1 = cur1 . next ; } while ( cur2 != null ){ pHead2Length ++; cur2 = cur2 . next ; } cur1 = pHead1 ; cur2 = pHead2 ; if ( pHead1Length >= pHead2Length ){ int lengthDif = pHead1Length - pHead2Length ; while ( lengthDif > 0 ){ cur1 = cur1 . next ; lengthDif --; } } else { int lengthDif = pHead2Length - pHead1Length ; while ( lengthDif > 0 ){ cur2 = cur2 . next ; lengthDif --; } } while ( cur1 != null && cur2 != null && cur1 != cur2 ){ cur1 = cur1 . next ; cur2 = cur2 . next ; } return cur1 ; } } 055-链表中环的入口结点 √ 题目描述: 给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。 思路： 1. 快慢指针，直到相遇 2. 慢指针回到head，快指针速度降为一次一步，再次相遇则为环入口 3. 需要注意快指针的边界和测试用例的情况 解题代码：（java） /* public class ListNode { int val; ListNode next = null; ListNode(int val) { this.val = val; } } */ /* 思路： 1. 快慢指针，直到相遇 2. 慢指针回到head，快指针速度降为一次一步，再次相遇则为环入口 3. 需要注意快指针的边界和测试用例的情况 */ public class Solution { public ListNode EntryNodeOfLoop ( ListNode pHead ) { if ( pHead == null || pHead . next == null ) return null ; ListNode pFast = pHead ; ListNode pSlow = pHead ; while ( pFast != null && pFast . next != null ){ pFast = pFast . next . next ; pSlow = pSlow . next ; if ( pFast == pSlow ){ pSlow = pHead ; while ( pFast != pSlow ){ pFast = pFast . next ; pSlow = pSlow . next ; } if ( pFast == pSlow ) return pFast ; } } return pSlow ; } } 056-删除链表中重复的结点 √ 题目描述 : 在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1->2->3->3->4->4->5 处理后为 1->2->5 思路: 1. 创建头结点，解决 1-1-2-2-3-3 这种一开始就遇到一样的问题 2. 创建preNode 确定前一个不重复的结点 3. 创建curNode 一直遍历，遇到重复的结点（值相同）就继续往后， 若值不相同，令preNode.next 指向 curNode.next curNode = curNode.next 解题代码：（Java） /* public class ListNode { int val; ListNode next = null; ListNode(int val) { this.val = val; } } */ /* 思路: 1. 创建头结点，解决 1-1-2-2-3-3 这种一开始就遇到一样的问题 2. 创建preNode 确定前一个不重复的结点 3. 创建curNode 一直遍历，遇到重复的结点（值相同）就继续往后， 若值不相同，令preNode.next 指向 curNode.next curNode = curNode.next */ public class Solution { public ListNode deleteDuplication ( ListNode pHead ) { ListNode headNode = new ListNode ( 0 ); headNode . next = pHead ; ListNode preNode = headNode ; ListNode curNode = pHead ; while ( curNode != null ){ // move and delete if ( curNode . next != null && curNode . val == curNode . next . val ){ while ( curNode . next != null && curNode . val == curNode . next . val ){ curNode = curNode . next ; } preNode . next = curNode . next ; curNode = curNode . next ; } // move else { preNode = curNode ; curNode = curNode . next ; } } return headNode . next ; } }","tags":"interview","url":"/20190919-LinkedList.html","loc":"/20190919-LinkedList.html"},{"title":"剑指offer|题库目录","text":"目录： [toc] LinkedList 003-从尾到头打印链表 014-链表中倒数第k个结点 015-反转链表 016-合并两个或k个有序链表 025-复杂链表的复制 036-两个链表的第一个公共结点 055-链表中环的入口结点 056-删除链表中重复的结点 Tree 004-重建二叉树 017-树的子结构 018-二叉树的镜像 022-从上往下打印二叉树 023-二叉搜索树的后序遍历序列 024-二叉树中和为某一值的路径 026-二叉搜索树与双向链表 038-二叉树的深度 039-平衡二叉树 057-二叉树的下一个结点 058-对称的二叉树 059-按之字形顺序打印二叉树 060-把二叉树打印成多行 061-序列化二叉树 062-二叉搜索树的第k个结点 Stack & Queue 005-用两个栈实现队列 020-包含min函数的栈 021-栈的压入、弹出序列 044-翻转单词顺序列(栈) 064-滑动窗口的最大值(双端队列) Heap 029-最小的K个数 Hash Table 034-第一个只出现一次的字符 图 065-矩阵中的路径(BFS) 066-机器人的运动范围(DFS) 其他算法 002-替换空格 013-调整数组顺序使奇数位于偶数前面 028-数组中出现次数超过一半的数字 031-整数中1出现的次数（从1到n整数中1出现的次数） 032-把数组排成最小的数 033-丑数 041-和为S的连续正数序列(滑动窗口思想) 042-和为S的两个数字(双指针思想) 043-左旋转字符串(矩阵翻转) 046-孩子们的游戏-圆圈中最后剩下的数(约瑟夫环) 051-构建乘积数组 References： 知乎专栏：sjz的学习和随想管理专栏写文章","tags":"interview","url":"/20190913剑指offer题库目录.html","loc":"/20190913剑指offer题库目录.html"},{"title":"2019-02-10左神算法课初级2笔记","text":"[toc] 初级2 题一 给定一个数组arr，和一个数num，请把小于等于num的数放在数 组的左边，大于num的数放在数组的右边。 要求额外空间复杂度O(1)，时间复杂度O(N) 思路 小于等于num区域 和 大于num区域 两个指针： 1. 一个 less --- 小于等于区最后一位 2. 一个 cur --- 当前遍历位置 荷兰国旗问题 给定一个数组arr，和一个数num，请把小于num的数放在数组的 左边，等于num的数放在数组的中间，大于num的数放在数组的 右边。 要求额外空间复杂度O(1)，时间复杂度O(N) 多加 等于区 and 大于区 快速排序 数组算法设计核心 指针移动 边界条件 工业界几乎不会允许递归实现出现，任何递归函数都一定可以转化成为非递归实现 堆 Heap 时间复杂度 O(N * logN) 额外空间复杂度 O(1) 堆结构 分清楚满二叉树，完全二叉树的区别 --- 堆是完全二叉树 具体实现用数组结构，但是我们可以逻辑上想象成一个二叉树 说到堆一定是有隐藏条件的 --- 大根堆 or 小根堆 大根堆 --- 任何子树中， 父节点 > 子节点 小跟堆 --- 任何子树中， 父节点 < 子节点 堆结构操作 heapInsert --- 增加一个新的节点操作 public static void heapInsert ( int [] arr , int index ) { while ( arr [ index ] > arr [( index - 1 ) / 2 ]) { swap ( arr , index , ( index - 1 ) / 2 ); index = ( index - 1 ) / 2 ; } } heapify --- 更新节点操作 public static void heapify ( int [] arr , int index , int size ) { int left = index * 2 + 1 ; while ( left < size ) { int largest = left + 1 < size && arr [ left + 1 ] > arr [ left ] ? left + 1 : left ; largest = arr [ largest ] > arr [ index ] ? largest : index ; if ( largest == index ) { break ; } swap ( arr , largest , index ); index = largest ; left = index * 2 + 1 ; } } 堆排序 排序算法稳定性 定义： 排序结果中，相同值的原始次序不会改变 意义： 保存原始排序中的信息，例如最开始是按照年龄排好序的一组数据，现在想要再对身高进行排序，这时如果排序算法稳定，则按照身高排好序的结果中，相同身高的数据项年龄依然保持原来的有序状态 快速排序和堆排序都是 不稳定的 一道坑爹的面试题： 能否将一个数组排序成，奇数放左边，偶数放右边，相对次序不改变 要求：时间复杂度为O(N),额外空间复杂度为O(1) 回答：做不到，因为奇偶和大于小于本质一样，都是一种 01标准 ，不是0就是1 这两个要求的条件本质和荷兰国旗问题的划分一样，所以这个问题等价于问我快速排序能不能够做到稳定。 比较器 comparator 本质；到底要求怎么排序？基于比较器就很好写代码了 例如，结构体排序时根据什么来排呢？ 例如，结构体中 Tips：面试技巧 分清楚压力面试还是故意刁难。 压力面试 --- 问题很尖锐，不给喘息时间，但是态度往往很端正，不会给你出了压力以外的负面情绪 故意刁难 --- 态度很不端正，摆架子，阴阳怪气，而且自己问的问题自己都没有认真准备答案 工业上的排序算法实现 当长度小于 60 时，直接用插入排序，因为常数项极低，而且O(N&#94;2)此时的劣势表现并不明显 当所排序的数组是基础类型 （byte，short，int，double，float）， 相同数据之间次序无所谓 ，直接用 快排 当所排序的数组是自己定义的结构体类型（student）里面带有多维信息，则用 归并排序 ，保持稳定 其他排序 --- 不基于比较的排序 特点： 受自身数据状况的影响太大 1 桶排序概念 桶是什么？ 一种表示各个数据出现频率的容器 计数排序 一个存储数据（词频）的容器，然后基于这个桶容器把所有数据统计一遍成为词频后（各个数据出现的次数）重新生成一组新的数据，所有过程没有进行过一次比较 经典题目： 给定一个数组，求如果排序之后，相邻两数的最大差值，要求时 间复杂度O(N)，且要求不能用非基于比较的排序 思路：N个数，分配N+1个桶（0~N），先遍历一遍找出最大值和最小值（max and min），min 放在0号桶，max 放在 N号桶，将剩下的N-1个桶均分成等大小的，放入剩下的 N-2个元素，那么必然至少会存在一个空桶。这样做完之后，我们可以排除一个可能性 ： 相邻两数的最大差值一定不会来自于同一个桶中的两个数，一定是来自不同桶的。 实现： 利用三个长度为 N+1 的数组 表示桶中的三个变量 int minList[],int maxList[],boolean isEmptyList[] 遍历每相邻两个桶的最值差： if !isEmptyList[i]： MaxGap = minList[i+1] - maxList[i]","tags":"study","url":"/20190210.html","loc":"/20190210.html"},{"title":"first_post","text":"Why everyone should have his own tech-blog? 1. Remark 2. Improve 3. Review","tags":"study","url":"/first_post.html","loc":"/first_post.html"}]};